{"/home/travis/build/npmtest/node-npmtest-soap/test.js":"/* istanbul instrument in package npmtest_soap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-soap/lib.npmtest_soap.js":"/* istanbul instrument in package npmtest_soap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_soap = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_soap = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-soap/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-soap && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_soap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_soap\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_soap.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_soap.rollup.js'] =\n            local.assetsDict['/assets.npmtest_soap.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_soap.__dirname +\n                    '/lib.npmtest_soap.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-soap/soap/index.js":"\"use strict\";\r\n\r\nmodule.exports = require('./lib/soap');\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/soap.js":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n */\r\n\r\n\"use strict\";\r\n\r\nvar Client = require('./client').Client,\r\n  Server = require('./server').Server,\r\n  HttpClient = require('./http'),\r\n  security = require('./security'),\r\n  passwordDigest = require('./utils').passwordDigest,\r\n  wsdl = require('./wsdl'),\r\n  WSDL = require('./wsdl').WSDL;\r\n\r\nfunction createCache() {\r\n  var cache = {};\r\n  return function (key, load, callback) {\r\n    if (!cache[key]) {\r\n      load(function (err, result) {\r\n        if (err) {\r\n          return callback(err);\r\n        }\r\n        cache[key] = result;\r\n        callback(null, result);\r\n      });\r\n    } else {\r\n      process.nextTick(function () {\r\n        callback(null, cache[key]);\r\n      });\r\n    }\r\n  };\r\n}\r\nvar getFromCache = createCache();\r\n\r\nfunction _requestWSDL(url, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n  var openWsdl = wsdl.open_wsdl.bind(null, url, options);\r\n\r\n  if (options.disableCache === true) {\r\n    openWsdl(callback);\r\n  } else {\r\n    getFromCache(url, openWsdl, callback);\r\n  }\r\n}\r\n\r\nfunction createClient(url, options, callback, endpoint) {\r\n  if (typeof options === 'function') {\r\n    endpoint = callback;\r\n    callback = options;\r\n    options = {};\r\n  }\r\n  endpoint = options.endpoint || endpoint;\r\n  _requestWSDL(url, options, function(err, wsdl) {\r\n    callback(err, wsdl && new Client(wsdl, endpoint, options));\r\n  });\r\n}\r\n\r\nfunction listen(server, pathOrOptions, services, xml) {\r\n  var options = {},\r\n    path = pathOrOptions,\r\n    uri = null;\r\n\r\n  if (typeof pathOrOptions === 'object') {\r\n    options = pathOrOptions;\r\n    path = options.path;\r\n    services = options.services;\r\n    xml = options.xml;\r\n    uri = options.uri;\r\n  }\r\n\r\n  var wsdl = new WSDL(xml || services, uri, options);\r\n  return new Server(server, path, services, wsdl, options);\r\n}\r\n\r\nexports.security = security;\r\nexports.BasicAuthSecurity = security.BasicAuthSecurity;\r\nexports.WSSecurity = security.WSSecurity;\r\nexports.WSSecurityCert = security.WSSecurityCert;\r\nexports.ClientSSLSecurity = security.ClientSSLSecurity;\r\nexports.ClientSSLSecurityPFX = security.ClientSSLSecurityPFX;\r\nexports.BearerSecurity = security.BearerSecurity;\r\nexports.createClient = createClient;\r\nexports.passwordDigest = passwordDigest;\r\nexports.listen = listen;\r\nexports.WSDL = WSDL;\r\n\r\n// Export Client and Server to allow customization\r\nexports.Server = Server;\r\nexports.Client = Client;\r\nexports.HttpClient = HttpClient;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/client.js":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n */\r\n\r\n\"use strict\";\r\n\r\n\r\nvar HttpClient = require('./http'),\r\n  assert = require('assert'),\r\n  events = require('events'),\r\n  util = require('util'),\r\n  debug = require('debug')('node-soap'),\r\n  findPrefix = require('./utils').findPrefix,\r\n  _ = require('lodash'),\r\n  concatStream = require('concat-stream'),\r\n  uuid = require('uuid');\r\n\r\nvar Client = function(wsdl, endpoint, options) {\r\n  events.EventEmitter.call(this);\r\n  options = options || {};\r\n  this.wsdl = wsdl;\r\n  this._initializeOptions(options);\r\n  this._initializeServices(endpoint);\r\n  this.httpClient = options.httpClient || new HttpClient(options);\r\n};\r\nutil.inherits(Client, events.EventEmitter);\r\n\r\nClient.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {\r\n  if (!this.soapHeaders) {\r\n    this.soapHeaders = [];\r\n  }\r\n  if (typeof soapHeader === 'object') {\r\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\r\n  }\r\n  return this.soapHeaders.push(soapHeader) - 1;\r\n};\r\n\r\nClient.prototype.changeSoapHeader = function(index, soapHeader, name, namespace, xmlns) {\r\n  if (!this.soapHeaders) {\r\n    this.soapHeaders = [];\r\n  }\r\n  if (typeof soapHeader === 'object') {\r\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\r\n  }\r\n  this.soapHeaders[index] = soapHeader;\r\n};\r\n\r\nClient.prototype.getSoapHeaders = function() {\r\n  return this.soapHeaders;\r\n};\r\n\r\nClient.prototype.clearSoapHeaders = function() {\r\n  this.soapHeaders = null;\r\n};\r\n\r\nClient.prototype.addHttpHeader = function(name, value) {\r\n  if (!this.httpHeaders) {\r\n    this.httpHeaders = {};\r\n  }\r\n  this.httpHeaders[name] = value;\r\n};\r\n\r\nClient.prototype.getHttpHeaders = function() {\r\n  return this.httpHeaders;\r\n};\r\n\r\nClient.prototype.clearHttpHeaders = function() {\r\n  this.httpHeaders = {};\r\n};\r\n\r\n\r\nClient.prototype.addBodyAttribute = function(bodyAttribute, name, namespace, xmlns) {\r\n  if (!this.bodyAttributes) {\r\n    this.bodyAttributes = [];\r\n  }\r\n  if (typeof bodyAttribute === 'object') {\r\n    var composition = '';\r\n    Object.getOwnPropertyNames(bodyAttribute).forEach(function(prop, idx, array) {\r\n      composition += ' ' + prop + '=\"' + bodyAttribute[prop] + '\"';\r\n    });\r\n    bodyAttribute = composition;\r\n  }\r\n  if (bodyAttribute.substr(0, 1) !== ' ') bodyAttribute = ' ' + bodyAttribute;\r\n  this.bodyAttributes.push(bodyAttribute);\r\n};\r\n\r\nClient.prototype.getBodyAttributes = function() {\r\n  return this.bodyAttributes;\r\n};\r\n\r\nClient.prototype.clearBodyAttributes = function() {\r\n  this.bodyAttributes = null;\r\n};\r\n\r\nClient.prototype.setEndpoint = function(endpoint) {\r\n  this.endpoint = endpoint;\r\n  this._initializeServices(endpoint);\r\n};\r\n\r\nClient.prototype.describe = function() {\r\n  var types = this.wsdl.definitions.types;\r\n  return this.wsdl.describeServices();\r\n};\r\n\r\nClient.prototype.setSecurity = function(security) {\r\n  this.security = security;\r\n};\r\n\r\nClient.prototype.setSOAPAction = function(SOAPAction) {\r\n  this.SOAPAction = SOAPAction;\r\n};\r\n\r\nClient.prototype._initializeServices = function(endpoint) {\r\n  var definitions = this.wsdl.definitions,\r\n    services = definitions.services;\r\n  for (var name in services) {\r\n    this[name] = this._defineService(services[name], endpoint);\r\n  }\r\n};\r\n\r\nClient.prototype._initializeOptions = function(options) {\r\n  this.streamAllowed = options.stream;\r\n  this.wsdl.options.attributesKey = options.attributesKey || 'attributes';\r\n  this.wsdl.options.envelopeKey = options.envelopeKey || 'soap';\r\n  if(options.ignoredNamespaces !== undefined) {\r\n    if(options.ignoredNamespaces.override !== undefined) {\r\n      if(options.ignoredNamespaces.override === true) {\r\n        if(options.ignoredNamespaces.namespaces !== undefined) {\r\n          this.wsdl.options.ignoredNamespaces = options.ignoredNamespaces.namespaces;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if(options.overrideRootElement !== undefined) {\r\n    this.wsdl.options.overrideRootElement = options.overrideRootElement;\r\n  }\r\n  this.wsdl.options.forceSoap12Headers = !!options.forceSoap12Headers;\r\n};\r\n\r\nClient.prototype._defineService = function(service, endpoint) {\r\n  var ports = service.ports,\r\n    def = {};\r\n  for (var name in ports) {\r\n    def[name] = this._definePort(ports[name], endpoint ? endpoint : ports[name].location);\r\n  }\r\n  return def;\r\n};\r\n\r\nClient.prototype._definePort = function(port, endpoint) {\r\n  var location = endpoint,\r\n    binding = port.binding,\r\n    methods = binding.methods,\r\n    def = {};\r\n  for (var name in methods) {\r\n    def[name] = this._defineMethod(methods[name], location);\r\n    this[name] = def[name];\r\n  }\r\n  return def;\r\n};\r\n\r\nClient.prototype._defineMethod = function(method, location) {\r\n  var self = this;\r\n  var temp;\r\n  return function(args, callback, options, extraHeaders) {\r\n    if (typeof args === 'function') {\r\n      callback = args;\r\n      args = {};\r\n    } else if (typeof options === 'function') {\r\n      temp = callback;\r\n      callback = options;\r\n      options = temp;\r\n    } else if (typeof extraHeaders === 'function') {\r\n      temp = callback;\r\n      callback = extraHeaders;\r\n      extraHeaders = options;\r\n      options = temp;\r\n    }\r\n    self._invoke(method, args, location, function(error, result, raw, soapHeader) {\r\n      callback(error, result, raw, soapHeader);\r\n    }, options, extraHeaders);\r\n  };\r\n};\r\n\r\nClient.prototype._isSequenceRequired = function(methodName) {\r\n  var tns = this.wsdl.definitions.$targetNamespace;\r\n  var methodRequestName = _.result(this.wsdl.definitions, 'messages.' + methodName + '.$name');\r\n  var args = _.result(this.wsdl.definitions, 'messages.' + methodRequestName + '.parts');\r\n\r\n  if(typeof args === 'undefined' && typeof _.pick(args, 'params') !== 'undefined') {\r\n    return false;\r\n  }\r\n  if(Object.keys(args).length === 1) {\r\n    return false;\r\n  }\r\n\r\n  var complexTypeName = _.result(this.wsdl.definitions, 'messages.' + methodRequestName + '.element.$name');\r\n  var modeOfComplexType = _.result(\r\n    this.wsdl.definitions,\r\n    'schemas[\\'' + tns + '\\'].elements.' + complexTypeName + '.children[0].children[0].name');\r\n\r\n  if(modeOfComplexType === 'sequence') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nClient.prototype._setSequenceArgs = function(argsScheme, args) {\r\n  var result = {};\r\n  if(typeof argsScheme !== 'object') {\r\n    return args;\r\n  }\r\n  for (var partIndex in argsScheme) {\r\n    if(typeof args[partIndex] === 'undefined') {\r\n      continue;\r\n    }\r\n    if(typeof argsScheme[partIndex] !== 'object') {\r\n      result[partIndex] = args[partIndex];\r\n    } else {\r\n      result[partIndex] = this._setSequenceArgs(argsScheme[partIndex], args[partIndex]);\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nClient.prototype._getArgsScheme = function(methodName) {\r\n  var methodRequestName = _.result(this.wsdl.definitions, 'messages.'+methodName+'.$name');\r\n  var args = _.result(this.wsdl.definitions, 'messages.' + methodRequestName + '.parts');\r\n\r\n  if(typeof args === 'undefined' && typeof _.pick(args, 'params') !== 'undefined') {\r\n    return [];\r\n  }\r\n  if(Object.keys(args).length === 1) {\r\n    return [];\r\n  }\r\n\r\n  return args;\r\n};\r\n\r\nClient.prototype._invoke = function(method, args, location, callback, options, extraHeaders) {\r\n  var self = this,\r\n    name = method.$name,\r\n    input = method.input,\r\n    output = method.output,\r\n    style = method.style,\r\n    defs = this.wsdl.definitions,\r\n    envelopeKey = this.wsdl.options.envelopeKey,\r\n    ns = defs.$targetNamespace,\r\n    encoding = '',\r\n    message = '',\r\n    xml = null,\r\n    req = null,\r\n    soapAction,\r\n    alias = findPrefix(defs.xmlns, ns),\r\n    headers = {\r\n      \"Content-Type\": \"text/xml; charset=utf-8\"\r\n    },\r\n    xmlnsSoap = \"xmlns:\" + envelopeKey + \"=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\";\r\n\r\n  if(this._isSequenceRequired(name)) {\r\n    var argsScheme = this._getArgsScheme(name);\r\n    if(argsScheme) {\r\n      args = this._setSequenceArgs(argsScheme, args);\r\n    }\r\n  }\r\n\r\n  if (this.wsdl.options.forceSoap12Headers) {\r\n    headers[\"Content-Type\"] = \"application/soap+xml; charset=utf-8\";\r\n    xmlnsSoap = \"xmlns:\" + envelopeKey + \"=\\\"http://www.w3.org/2003/05/soap-envelope\\\"\";\r\n  }\r\n\r\n  if (this.SOAPAction) {\r\n    soapAction = this.SOAPAction;\r\n  } else if (method.soapAction !== undefined && method.soapAction !== null) {\r\n    soapAction = method.soapAction;\r\n  } else {\r\n    soapAction = ((ns.lastIndexOf(\"/\") !== ns.length - 1) ? ns + \"/\" : ns) + name;\r\n  }\r\n\r\n  if (!this.wsdl.options.forceSoap12Headers) {\r\n    headers.SOAPAction = '\"' + soapAction + '\"';\r\n  }\r\n\r\n  options = options || {};\r\n\r\n  //Add extra headers\r\n  for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }\r\n  for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }\r\n\r\n  // Allow the security object to add headers\r\n  if (self.security && self.security.addHeaders)\r\n    self.security.addHeaders(headers);\r\n  if (self.security && self.security.addOptions)\r\n    self.security.addOptions(options);\r\n\r\n  if ((style === 'rpc')&& ( ( input.parts || input.name===\"element\" ) || args === null) ) {\r\n    assert.ok(!style || style === 'rpc', 'invalid message definition for document style binding');\r\n    message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==\"element\" ));\r\n    (method.inputSoap === 'encoded') && (encoding = 'soap:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\" ');\r\n  } else {\r\n    assert.ok(!style || style === 'document', 'invalid message definition for rpc style binding');\r\n    // pass `input.$lookupType` if `input.$type` could not be found\r\n    message = self.wsdl.objectToDocumentXML(input.$name, args, input.targetNSAlias, input.targetNamespace, (input.$type || input.$lookupType));\r\n  }\r\n  xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" +\r\n    \"<\" + envelopeKey + \":Envelope \" +\r\n    xmlnsSoap + \" \" +\r\n    \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" +\r\n    encoding +\r\n    this.wsdl.xmlnsInEnvelope + '>' +\r\n    ((self.soapHeaders || self.security) ?\r\n      (\r\n        \"<\" + envelopeKey + \":Header>\" +\r\n        (self.soapHeaders ? self.soapHeaders.join(\"\\n\") : \"\") +\r\n        (self.security && !self.security.postProcess ? self.security.toXML() : \"\") +\r\n        \"</\" + envelopeKey + \":Header>\"\r\n      )\r\n      :\r\n        ''\r\n      ) +\r\n    \"<\" + envelopeKey + \":Body\" +\r\n    (self.bodyAttributes ? self.bodyAttributes.join(' ') : '') +\r\n    (self.security && self.security.postProcess ? ' Id=\"_0\"' : '') +\r\n    \">\" +\r\n    message +\r\n    \"</\" + envelopeKey + \":Body>\" +\r\n    \"</\" + envelopeKey + \":Envelope>\";\r\n\r\n  if(self.security && self.security.postProcess){\r\n    xml = self.security.postProcess(xml, envelopeKey);\r\n  }\r\n\r\n  self.lastMessage = message;\r\n  self.lastRequest = xml;\r\n  self.lastEndpoint = location;\r\n\r\n  var eid = options.exchangeId || uuid.v4();\r\n\r\n  self.emit('message', message, eid);\r\n  self.emit('request', xml, eid);\r\n\r\n  var tryJSONparse = function(body) {\r\n    try {\r\n      return JSON.parse(body);\r\n    }\r\n    catch(err) {\r\n      return undefined;\r\n    }\r\n  };\r\n\r\n  if (this.streamAllowed && typeof self.httpClient.requestStream === 'function') {\r\n    callback = _.once(callback);\r\n    var startTime = Date.now();\r\n    req = self.httpClient.requestStream(location, xml, headers, options, self);\r\n    self.lastRequestHeaders = req.headers;\r\n    var onError = function onError(err) {\r\n      self.lastResponse = null;\r\n      self.lastResponseHeaders = null;\r\n      self.lastElapsedTime = null;\r\n      self.emit('response', null, null, eid);\r\n\r\n      callback(err);\r\n    };\r\n    req.on('error', onError);\r\n    req.on('response', function (response) {\r\n      response.on('error', onError);\r\n\r\n      // When the output element cannot be looked up in the wsdl, play it safe and\r\n      // don't stream\r\n      if(response.statusCode !== 200 || !output || !output.$lookupTypes) {\r\n        response.pipe(concatStream({encoding: 'string'}, function (body) {\r\n          self.lastResponse = body;\r\n          self.lastResponseHeaders = response && response.headers;\r\n          self.lastElapsedTime = Date.now() - startTime;\r\n          self.emit('response', body, response, eid);\r\n\r\n          return parseSync(body, response);\r\n\r\n        }));\r\n        return;\r\n      }\r\n\r\n      self.wsdl.xmlToObject(response, function (error, obj) {\r\n        self.lastResponse = response;\r\n        self.lastResponseHeaders = response && response.headers;\r\n        self.lastElapsedTime = Date.now() - startTime;\r\n        self.emit('response', '<stream>', response, eid);\r\n\r\n        if (error) {\r\n          error.response = response;\r\n          error.body = '<stream>';\r\n          self.emit('soapError', error, eid);\r\n          return callback(error, response);\r\n        }\r\n\r\n        return finish(obj, '<stream>', response);\r\n      });\r\n    });\r\n    return;\r\n  }\r\n\r\n  req = self.httpClient.request(location, xml, function(err, response, body) {\r\n    self.lastResponse = body;\r\n    self.lastResponseHeaders = response && response.headers;\r\n    self.lastElapsedTime = response && response.elapsedTime;\r\n    self.emit('response', body, response, eid);\r\n\r\n    if (err) {\r\n      callback(err);\r\n    } else {\r\n      return parseSync(body, response);\r\n    }\r\n  }, headers, options, self);\r\n\r\n  function parseSync(body, response) {\r\n    var obj;\r\n    try {\r\n      obj = self.wsdl.xmlToObject(body);\r\n    } catch (error) {\r\n      //  When the output element cannot be looked up in the wsdl and the body is JSON\r\n      //  instead of sending the error, we pass the body in the response.\r\n      if(!output || !output.$lookupTypes) {\r\n        debug('Response element is not present. Unable to convert response xml to json.');\r\n        //  If the response is JSON then return it as-is.\r\n        var json = _.isObject(body) ? body : tryJSONparse(body);\r\n        if (json) {\r\n          return callback(null, response, json);\r\n        }\r\n      }\r\n      error.response = response;\r\n      error.body = body;\r\n      self.emit('soapError', error, eid);\r\n      return callback(error, response, body);\r\n    }\r\n    return finish(obj, body, response);\r\n  }\r\n\r\n  function finish(obj, body, response) {\r\n    var result;\r\n\r\n    if (!output){\r\n      // one-way, no output expected\r\n      return callback(null, null, body, obj.Header);\r\n    }\r\n\r\n    if( typeof obj.Body !== 'object' ) {\r\n      var error = new Error('Cannot parse response');\r\n      error.response = response;\r\n      error.body = body;\r\n      return callback(error, obj, body);\r\n    }\r\n\r\n    // if Soap Body is empty\r\n    if (!obj.Body) {\r\n      return callback(null, obj, body, obj.Header);\r\n    }\r\n\r\n    result = obj.Body[output.$name];\r\n    // RPC/literal response body may contain elements with added suffixes I.E.\r\n    // 'Response', or 'Output', or 'Out'\r\n    // This doesn't necessarily equal the ouput message name. See WSDL 1.1 Section 2.4.5\r\n    if(!result){\r\n      result = obj.Body[output.$name.replace(/(?:Out(?:put)?|Response)$/, '')];\r\n    }\r\n    if (!result) {\r\n      ['Response', 'Out', 'Output'].forEach(function (term) {\r\n        if (obj.Body.hasOwnProperty(name + term)) {\r\n          return result = obj.Body[name + term];\r\n        }\r\n      });\r\n    }\r\n\r\n    callback(null, result, body, obj.Header);\r\n  }\r\n\r\n  // Added mostly for testability, but possibly useful for debugging\r\n  if(req && req.headers) //fixes an issue when req or req.headers is indefined\r\n    self.lastRequestHeaders = req.headers;\r\n};\r\n\r\nexports.Client = Client;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/http.js":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n */\r\n\r\n'use strict';\r\n\r\nvar url = require('url');\r\nvar req = require('request');\r\nvar debug = require('debug')('node-soap');\r\n\r\nvar VERSION = require('../package.json').version;\r\n\r\n/**\r\n * A class representing the http client\r\n * @param {Object} [options] Options object. It allows the customization of\r\n * `request` module\r\n *\r\n * @constructor\r\n */\r\nfunction HttpClient(options) {\r\n  options = options || {};\r\n  this._request = options.request || req;\r\n}\r\n\r\n/**\r\n * Build the HTTP request (method, uri, headers, ...)\r\n * @param {String} rurl The resource url\r\n * @param {Object|String} data The payload\r\n * @param {Object} exheaders Extra http headers\r\n * @param {Object} exoptions Extra options\r\n * @returns {Object} The http request object for the `request` module\r\n */\r\nHttpClient.prototype.buildRequest = function(rurl, data, exheaders, exoptions) {\r\n  var curl = url.parse(rurl);\r\n  var secure = curl.protocol === 'https:';\r\n  var host = curl.hostname;\r\n  var port = parseInt(curl.port, 10);\r\n  var path = [curl.pathname || '/', curl.search || '', curl.hash || ''].join('');\r\n  var method = data ? 'POST' : 'GET';\r\n  var headers = {\r\n    'User-Agent': 'node-soap/' + VERSION,\r\n    'Accept': 'text/html,application/xhtml+xml,application/xml,text/xml;q=0.9,*/*;q=0.8',\r\n    'Accept-Encoding': 'none',\r\n    'Accept-Charset': 'utf-8',\r\n    'Connection': 'close',\r\n    'Host': host + (isNaN(port) ? '' : ':' + port)\r\n  };\r\n  var attr;\r\n  var header;\r\n  var mergeOptions = ['headers'];\r\n\r\n  if (typeof data === 'string') {\r\n    headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\r\n    headers['Content-Type'] = 'application/x-www-form-urlencoded';\r\n  }\r\n\r\n  exheaders = exheaders || {};\r\n  for (attr in exheaders) {\r\n    headers[attr] = exheaders[attr];\r\n  }\r\n\r\n  var options = {\r\n    uri: curl,\r\n    method: method,\r\n    headers: headers,\r\n    followAllRedirects: true\r\n  };\r\n\r\n\r\n  options.body = data;\r\n\r\n\r\n  exoptions = exoptions || {};\r\n  for (attr in exoptions) {\r\n    if (mergeOptions.indexOf(attr) !== -1) {\r\n      for (header in exoptions[attr]) {\r\n        options[attr][header] = exoptions[attr][header];\r\n      }\r\n    } else {\r\n      options[attr] = exoptions[attr];\r\n    }\r\n  }\r\n  debug('Http request: %j', options);\r\n  return options;\r\n};\r\n\r\n/**\r\n * Handle the http response\r\n * @param {Object} The req object\r\n * @param {Object} res The res object\r\n * @param {Object} body The http body\r\n * @param {Object} The parsed body\r\n */\r\nHttpClient.prototype.handleResponse = function(req, res, body) {\r\n  debug('Http response body: %j', body);\r\n  if (typeof body === 'string') {\r\n    // Remove any extra characters that appear before or after the SOAP\r\n    // envelope.\r\n    var match =\r\n      body.replace(/<!--[\\s\\S]*?-->/, \"\").match(/(?:<\\?[^?]*\\?>[\\s]*)?<([^:]*):Envelope([\\S\\s]*)<\\/\\1:Envelope>/i);\r\n    if (match) {\r\n      body = match[0];\r\n    }\r\n  }\r\n  return body;\r\n};\r\n\r\nHttpClient.prototype.request = function(rurl, data, callback, exheaders, exoptions) {\r\n  var self = this;\r\n  var options = self.buildRequest(rurl, data, exheaders, exoptions);\r\n  var headers = options.headers;\r\n  var req = self._request(options, function(err, res, body) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n    body = self.handleResponse(req, res, body);\r\n    callback(null, res, body);\r\n  });\r\n\r\n  return req;\r\n};\r\n\r\nHttpClient.prototype.requestStream = function(rurl, data, exheaders, exoptions) {\r\n  var self = this;\r\n  var options = self.buildRequest(rurl, data, exheaders, exoptions);\r\n  return self._request(options);\r\n};\r\n\r\nmodule.exports = HttpClient;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/utils.js":"\r\n\"use strict\";\r\nvar crypto = require('crypto');\r\nexports.passwordDigest = function passwordDigest(nonce, created, password) {\r\n  // digest = base64 ( sha1 ( nonce + created + password ) )\r\n  var pwHash = crypto.createHash('sha1');\r\n  var rawNonce = new Buffer(nonce || '', 'base64').toString('binary');\r\n  pwHash.update(rawNonce + created + password);\r\n  return pwHash.digest('base64');\r\n};\r\n\r\n\r\nvar TNS_PREFIX = '__tns__'; // Prefix for targetNamespace\r\n\r\nexports.TNS_PREFIX = TNS_PREFIX;\r\n\r\n/**\r\n * Find a key from an object based on the value\r\n * @param {Object} Namespace prefix/uri mapping\r\n * @param {*} nsURI value\r\n * @returns {String} The matching key\r\n */\r\nexports.findPrefix = function(xmlnsMapping, nsURI) {\r\n  for (var n in xmlnsMapping) {\r\n    if (n === TNS_PREFIX) continue;\r\n    if (xmlnsMapping[n] === nsURI) {\r\n      return n;\r\n    }\r\n  }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/server.js":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n */\r\n\r\n\"use strict\";\r\n\r\nfunction getDateString(d) {\r\n  function pad(n) {\r\n    return n < 10 ? '0' + n : n;\r\n  }\r\n  return d.getUTCFullYear() + '-'\r\n    + pad(d.getUTCMonth() + 1) + '-'\r\n    + pad(d.getUTCDate()) + 'T'\r\n    + pad(d.getUTCHours()) + ':'\r\n    + pad(d.getUTCMinutes()) + ':'\r\n    + pad(d.getUTCSeconds()) + 'Z';\r\n}\r\n\r\nvar url = require('url'),\r\n  compress = null,\r\n  events = require('events'),\r\n  util = require('util'),\r\n  findPrefix = require('./utils').findPrefix;\r\n\r\ntry {\r\n  compress = require(\"compress\");\r\n} catch (error) {\r\n}\r\n\r\nvar Server = function (server, path, services, wsdl, options) {\r\n  var self = this;\r\n\r\n  events.EventEmitter.call(this);\r\n\r\n  options = options || {};\r\n  this.path = path;\r\n  this.services = services;\r\n  this.wsdl = wsdl;\r\n  this.suppressStack = options && options.suppressStack;\r\n\r\n  if (path[path.length - 1] !== '/')\r\n    path += '/';\r\n  wsdl.onReady(function (err) {\r\n    if (typeof server.route === 'function' && typeof server.use === 'function') {\r\n      //handle only the required URL path for express server\r\n      server.route(path).all(function (req, res, next) {\r\n        if (typeof self.authorizeConnection === 'function') {\r\n          if (!self.authorizeConnection(req)) {\r\n            res.end();\r\n            return;\r\n          }\r\n        }\r\n        self._requestListener(req, res);\r\n      });\r\n    } else {\r\n      var listeners = server.listeners('request').slice();\r\n      server.removeAllListeners('request');\r\n      server.addListener('request', function (req, res) {\r\n        if (typeof self.authorizeConnection === 'function') {\r\n          if (!self.authorizeConnection(req)) {\r\n            res.end();\r\n            return;\r\n          }\r\n        }\r\n        var reqPath = url.parse(req.url).pathname;\r\n        if (reqPath[reqPath.length - 1] !== '/') {\r\n          reqPath += '/';\r\n        }\r\n        if (path === reqPath) {\r\n          self._requestListener(req, res);\r\n        } else {\r\n          for (var i = 0, len = listeners.length; i < len; i++) {\r\n            listeners[i].call(this, req, res);\r\n          }\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  this._initializeOptions(options);\r\n};\r\nutil.inherits(Server, events.EventEmitter);\r\n\r\nServer.prototype.addSoapHeader = function (soapHeader, name, namespace, xmlns) {\r\n  if (!this.soapHeaders) {\r\n    this.soapHeaders = [];\r\n  }\r\n  if (typeof soapHeader === 'object') {\r\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\r\n  }\r\n  return this.soapHeaders.push(soapHeader) - 1;\r\n};\r\n\r\nServer.prototype.changeSoapHeader = function (index, soapHeader, name, namespace, xmlns) {\r\n  if (!this.soapHeaders) {\r\n    this.soapHeaders = [];\r\n  }\r\n  if (typeof soapHeader === 'object') {\r\n    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);\r\n  }\r\n  this.soapHeaders[index] = soapHeader;\r\n};\r\n\r\nServer.prototype.getSoapHeaders = function () {\r\n  return this.soapHeaders;\r\n};\r\n\r\nServer.prototype.clearSoapHeaders = function () {\r\n  this.soapHeaders = null;\r\n};\r\n\r\nServer.prototype._initializeOptions = function (options) {\r\n  this.wsdl.options.attributesKey = options.attributesKey || 'attributes';\r\n};\r\n\r\nServer.prototype._processRequestXml = function (req, res, xml) {\r\n  var self = this;\r\n  var result;\r\n  var error;\r\n  try {\r\n    if (typeof self.log === 'function') {\r\n      self.log(\"received\", xml);\r\n    }\r\n    self._process(xml, req, function (result, statusCode) {\r\n      if (statusCode) {\r\n        res.statusCode = statusCode;\r\n      }\r\n      res.write(result);\r\n      res.end();\r\n      if (typeof self.log === 'function') {\r\n        self.log(\"replied\", result);\r\n      }\r\n    });\r\n  } catch (err) {\r\n    if (err.Fault !== undefined) {\r\n      return self._sendError(err.Fault, function (result, statusCode) {\r\n        res.statusCode = statusCode || 500;\r\n        res.write(result);\r\n        res.end();\r\n        if (typeof self.log === 'function') {\r\n          self.log(\"error\", err);\r\n        }\r\n      }, new Date().toISOString());\r\n    } else {\r\n      error = err.stack ? (self.suppressStack === true ? err.message : err.stack) : err;\r\n      res.statusCode = 500;\r\n      res.write(error);\r\n      res.end();\r\n      if (typeof self.log === 'function') {\r\n        self.log(\"error\", error);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nServer.prototype._requestListener = function (req, res) {\r\n  var self = this;\r\n  var reqParse = url.parse(req.url);\r\n  var reqPath = reqParse.pathname;\r\n  var reqQuery = reqParse.search;\r\n\r\n  if (typeof self.log === 'function') {\r\n    self.log(\"info\", \"Handling \" + req.method + \" on \" + req.url);\r\n  }\r\n\r\n  if (req.method === 'GET') {\r\n    if (reqQuery && reqQuery.toLowerCase() === '?wsdl') {\r\n      if (typeof self.log === 'function') {\r\n        self.log(\"info\", \"Wants the WSDL\");\r\n      }\r\n      res.setHeader(\"Content-Type\", \"application/xml\");\r\n      res.write(self.wsdl.toXML());\r\n    }\r\n    res.end();\r\n  } else if (req.method === 'POST') {\r\n    if (typeof req.headers['content-type'] !== \"undefined\") {\r\n      res.setHeader('Content-Type', req.headers['content-type']);\r\n    } else {\r\n      res.setHeader('Content-Type', \"application/xml\");\r\n    }\r\n\r\n    //request body is already provided by an express middleware\r\n    //in this case unzipping should also be done by the express middleware itself\r\n    if (req.body) {\r\n      return self._processRequestXml(req, res, req.body.toString());\r\n    }\r\n\r\n    var chunks = [], gunzip;\r\n    if (compress && req.headers[\"content-encoding\"] === \"gzip\") {\r\n      gunzip = new compress.Gunzip();\r\n      gunzip.init();\r\n    }\r\n    req.on('data', function (chunk) {\r\n      if (gunzip)\r\n        chunk = gunzip.inflate(chunk, \"binary\");\r\n      chunks.push(chunk);\r\n    });\r\n    req.on('end', function () {\r\n      var xml = chunks.join('');\r\n      var result;\r\n      var error;\r\n      if (gunzip) {\r\n        gunzip.end();\r\n        gunzip = null;\r\n      }\r\n      self._processRequestXml(req, res, xml);\r\n    });\r\n  }\r\n  else {\r\n    res.end();\r\n  }\r\n};\r\n\r\nServer.prototype._process = function (input, req, callback) {\r\n  var self = this,\r\n    pathname = url.parse(req.url).pathname.replace(/\\/$/, ''),\r\n    obj = this.wsdl.xmlToObject(input),\r\n    body = obj.Body,\r\n    headers = obj.Header,\r\n    bindings = this.wsdl.definitions.bindings, binding,\r\n    method, methodName,\r\n    serviceName, portName,\r\n    includeTimestamp = obj.Header && obj.Header.Security && obj.Header.Security.Timestamp;\r\n\r\n  if (typeof self.authenticate === 'function') {\r\n    if (!obj.Header || !obj.Header.Security) {\r\n      throw new Error('No security header');\r\n    }\r\n    if (!self.authenticate(obj.Header.Security)) {\r\n      throw new Error('Invalid username or password');\r\n    }\r\n  }\r\n\r\n  if (typeof self.log === 'function') {\r\n    self.log(\"info\", \"Attempting to bind to \" + pathname);\r\n  }\r\n\r\n  //Avoid Cannot convert undefined or null to object due to Object.keys(body)\r\n  //and throw more meaningful error\r\n  if (!body) {\r\n    throw new Error('Failed to parse the SOAP Message body');\r\n  }\r\n\r\n  // use port.location and current url to find the right binding\r\n  binding = (function (self) {\r\n    var services = self.wsdl.definitions.services;\r\n    var firstPort;\r\n    var name;\r\n    for (name in services) {\r\n      serviceName = name;\r\n      var service = services[serviceName];\r\n      var ports = service.ports;\r\n      for (name in ports) {\r\n        portName = name;\r\n        var port = ports[portName];\r\n        var portPathname = url.parse(port.location).pathname.replace(/\\/$/, '');\r\n\r\n        if (typeof self.log === 'function') {\r\n          self.log(\"info\", \"Trying \" + portName + \" from path \" + portPathname);\r\n        }\r\n\r\n        if (portPathname === pathname)\r\n          return port.binding;\r\n\r\n        // The port path is almost always wrong for generated WSDLs\r\n        if (!firstPort) {\r\n          firstPort = port;\r\n        }\r\n      }\r\n    }\r\n    return !firstPort ? void 0 : firstPort.binding;\r\n  })(this);\r\n\r\n  if (!binding) {\r\n    throw new Error('Failed to bind to WSDL');\r\n  }\r\n\r\n  try {\r\n    if (binding.style === 'rpc') {\r\n      methodName = Object.keys(body)[0];\r\n\r\n      self.emit('request', obj, methodName);\r\n      if (headers)\r\n        self.emit('headers', headers, methodName);\r\n\r\n      self._executeMethod({\r\n        serviceName: serviceName,\r\n        portName: portName,\r\n        methodName: methodName,\r\n        outputName: methodName + 'Response',\r\n        args: body[methodName],\r\n        headers: headers,\r\n        style: 'rpc'\r\n      }, req, callback);\r\n    } else {\r\n      var messageElemName = (Object.keys(body)[0] === 'attributes' ? Object.keys(body)[1] : Object.keys(body)[0]);\r\n      var pair = binding.topElements[messageElemName];\r\n\r\n      self.emit('request', obj, pair.methodName);\r\n      if (headers)\r\n        self.emit('headers', headers, pair.methodName);\r\n\r\n      self._executeMethod({\r\n        serviceName: serviceName,\r\n        portName: portName,\r\n        methodName: pair.methodName,\r\n        outputName: pair.outputName,\r\n        args: body[messageElemName],\r\n        headers: headers,\r\n        style: 'document'\r\n      }, req, callback, includeTimestamp);\r\n    }\r\n  }\r\n  catch (error) {\r\n    if (error.Fault !== undefined) {\r\n      return self._sendError(error.Fault, callback, includeTimestamp);\r\n    }\r\n\r\n    throw error;\r\n  }\r\n};\r\n\r\nServer.prototype._executeMethod = function (options, req, callback, includeTimestamp) {\r\n  options = options || {};\r\n  var self = this,\r\n    method, body,\r\n    serviceName = options.serviceName,\r\n    portName = options.portName,\r\n    methodName = options.methodName,\r\n    outputName = options.outputName,\r\n    args = options.args,\r\n    style = options.style,\r\n    handled = false;\r\n\r\n  try {\r\n    method = this.services[serviceName][portName][methodName];\r\n  } catch (error) {\r\n    return callback(this._envelope('', includeTimestamp));\r\n  }\r\n\r\n  function handleResult(error, result) {\r\n    if (handled)\r\n      return;\r\n    handled = true;\r\n\r\n    if (error && error.Fault !== undefined) {\r\n      return self._sendError(error.Fault, callback, includeTimestamp);\r\n    }\r\n    else if (result === undefined) {\r\n      // Backward compatibility to support one argument callback style\r\n      result = error;\r\n    }\r\n\r\n    if (style === 'rpc') {\r\n      body = self.wsdl.objectToRpcXML(outputName, result, '', self.wsdl.definitions.$targetNamespace);\r\n    } else {\r\n      var element = self.wsdl.definitions.services[serviceName].ports[portName].binding.methods[methodName].output;\r\n      body = self.wsdl.objectToDocumentXML(outputName, result, element.targetNSAlias, element.targetNamespace);\r\n    }\r\n    callback(self._envelope(body, includeTimestamp));\r\n  }\r\n\r\n  if (!self.wsdl.definitions.services[serviceName].ports[portName].binding.methods[methodName].output) {\r\n    // no output defined = one-way operation so return empty response\r\n    handled = true;\r\n    callback('');\r\n  }\r\n\r\n  var result = method(args, handleResult, options.headers, req);\r\n  if (typeof result !== 'undefined') {\r\n    handleResult(result);\r\n  }\r\n};\r\n\r\nServer.prototype._envelope = function (body, includeTimestamp) {\r\n  var defs = this.wsdl.definitions,\r\n    ns = defs.$targetNamespace,\r\n    encoding = '',\r\n    alias = findPrefix(defs.xmlns, ns);\r\n  var xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" +\r\n    \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \" +\r\n    encoding +\r\n    this.wsdl.xmlnsInEnvelope + '>';\r\n  var headers = '';\r\n\r\n  if (includeTimestamp) {\r\n    var now = new Date();\r\n    var created = getDateString(now);\r\n    var expires = getDateString(new Date(now.getTime() + (1000 * 600)));\r\n\r\n    headers += \"<o:Security soap:mustUnderstand=\\\"1\\\" \" +\r\n      \"xmlns:o=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\\\" \" +\r\n      \"xmlns:u=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\\\">\" +\r\n      \"    <u:Timestamp u:Id=\\\"_0\\\">\" +\r\n      \"      <u:Created>\" + created + \"</u:Created>\" +\r\n      \"      <u:Expires>\" + expires + \"</u:Expires>\" +\r\n      \"    </u:Timestamp>\" +\r\n      \"  </o:Security>\\n\";\r\n  }\r\n\r\n  if (this.soapHeaders) {\r\n    headers += this.soapHeaders.join(\"\\n\");\r\n  }\r\n\r\n  if (headers !== '') {\r\n    xml += \"<soap:Header>\" + headers + \"</soap:Header>\";\r\n  }\r\n\r\n  xml += \"<soap:Body>\" +\r\n    body +\r\n    \"</soap:Body>\" +\r\n    \"</soap:Envelope>\";\r\n  return xml;\r\n};\r\n\r\nServer.prototype._sendError = function (soapFault, callback, includeTimestamp) {\r\n  var self = this,\r\n    fault;\r\n\r\n  var statusCode;\r\n  if (soapFault.statusCode) {\r\n    statusCode = soapFault.statusCode;\r\n    soapFault.statusCode = undefined;\r\n  }\r\n\r\n  if (soapFault.faultcode) {\r\n    // Soap 1.1 error style\r\n    // Root element will be prependend with the soap NS\r\n    // It must match the NS defined in the Envelope (set by the _envelope method)\r\n    fault = self.wsdl.objectToDocumentXML(\"soap:Fault\", soapFault, undefined);\r\n  }\r\n  else {\r\n    // Soap 1.2 error style.\r\n    // 3rd param is the NS prepended to all elements\r\n    // It must match the NS defined in the Envelope (set by the _envelope method)\r\n    fault = self.wsdl.objectToDocumentXML(\"Fault\", soapFault, \"soap\");\r\n  }\r\n\r\n  return callback(self._envelope(fault, includeTimestamp), statusCode);\r\n};\r\n\r\nexports.Server = Server;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/security/index.js":"\"use strict\";\r\n\r\nmodule.exports = {\r\n  BasicAuthSecurity: require('./BasicAuthSecurity')\r\n, ClientSSLSecurity: require('./ClientSSLSecurity')\r\n, ClientSSLSecurityPFX: require('./ClientSSLSecurityPFX')\r\n, WSSecurity: require('./WSSecurity')\r\n, BearerSecurity: require('./BearerSecurity')\r\n, WSSecurityCert: require('./WSSecurityCert')\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/security/BasicAuthSecurity.js":"\"use strict\";\r\n\r\nvar _ = require('lodash');\r\n\r\nfunction BasicAuthSecurity(username, password, defaults) {\r\n  this._username = username;\r\n  this._password = password;\r\n  this.defaults = {};\r\n  _.merge(this.defaults, defaults);\r\n}\r\n\r\nBasicAuthSecurity.prototype.addHeaders = function(headers) {\r\n  headers.Authorization = 'Basic ' + new Buffer((this._username + ':' + this._password) || '').toString('base64');\r\n};\r\n\r\nBasicAuthSecurity.prototype.toXML = function() {\r\n  return '';\r\n};\r\n\r\nBasicAuthSecurity.prototype.addOptions = function(options) {\r\n  _.merge(options, this.defaults);\r\n};\r\n\r\nmodule.exports = BasicAuthSecurity;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/security/ClientSSLSecurity.js":"'use strict';\r\n\r\nvar fs = require('fs')\r\n  , https = require('https')\r\n  , _ = require('lodash');\r\n\r\n/**\r\n * activates SSL for an already existing client\r\n *\r\n * @module ClientSSLSecurity\r\n * @param {Buffer|String}   key\r\n * @param {Buffer|String}   cert\r\n * @param {Buffer|String|Array}   [ca]\r\n * @param {Object}          [defaults]\r\n * @constructor\r\n */\r\nfunction ClientSSLSecurity(key, cert, ca, defaults) {\r\n  if (key) {\r\n    if(Buffer.isBuffer(key)) {\r\n      this.key = key;\r\n    } else if (typeof key === 'string') {\r\n      this.key = fs.readFileSync(key);\r\n    } else {\r\n      throw new Error('key should be a buffer or a string!');\r\n    }\r\n  }\r\n\r\n  if (cert) {\r\n    if(Buffer.isBuffer(cert)) {\r\n      this.cert = cert;\r\n    } else if (typeof cert === 'string') {\r\n      this.cert = fs.readFileSync(cert);\r\n    } else {\r\n      throw new Error('cert should be a buffer or a string!');\r\n    }\r\n  }\r\n\r\n  if (ca) {\r\n    if(Buffer.isBuffer(ca) || Array.isArray(ca)) {\r\n      this.ca = ca;\r\n    } else if (typeof ca === 'string') {\r\n      this.ca = fs.readFileSync(ca);\r\n    } else {\r\n      defaults = ca;\r\n      this.ca = null;\r\n    }\r\n  }\r\n\r\n  this.defaults = {};\r\n  _.merge(this.defaults, defaults);\r\n}\r\n\r\nClientSSLSecurity.prototype.toXML = function(headers) {\r\n  return '';\r\n};\r\n\r\nClientSSLSecurity.prototype.addOptions = function(options) {\r\n  options.key = this.key;\r\n  options.cert = this.cert;\r\n  options.ca = this.ca;\r\n  _.merge(options, this.defaults);\r\n  options.agent = new https.Agent(options);\r\n};\r\n\r\nmodule.exports = ClientSSLSecurity;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/security/ClientSSLSecurityPFX.js":"'use strict';\r\n\r\nvar fs = require('fs')\r\n  , https = require('https')\r\n  , _ = require('lodash');\r\n\r\n/**\r\n * activates SSL for an already existing client using a PFX cert\r\n *\r\n * @module ClientSSLSecurityPFX\r\n * @param {Buffer|String}   pfx\r\n * @param {String}   passphrase\r\n * @constructor\r\n */\r\nfunction ClientSSLSecurityPFX(pfx, passphrase, defaults) {\r\n  if (typeof passphrase === 'object') {\r\n    defaults = passphrase;\r\n  }\r\n  if (pfx) {\r\n    if (Buffer.isBuffer(pfx)) {\r\n      this.pfx = pfx;\r\n    } else if (typeof pfx === 'string') {\r\n      this.pfx = fs.readFileSync(pfx);\r\n    } else {\r\n      throw new Error('supplied pfx file should be a buffer or a file location');\r\n    }\r\n  }\r\n\r\n  if (passphrase) {\r\n    if (typeof passphrase === 'string') {\r\n      this.passphrase = passphrase;\r\n    }\r\n  }\r\n  this.defaults = {};\r\n  _.merge(this.defaults, defaults);\r\n}\r\n\r\nClientSSLSecurityPFX.prototype.toXML = function(headers) {\r\n  return '';\r\n};\r\n\r\nClientSSLSecurityPFX.prototype.addOptions = function(options) {\r\n  options.pfx = this.pfx;\r\n  if (this.passphrase) {\r\n    options.passphrase = this.passphrase;\r\n  }\r\n  _.merge(options, this.defaults);\r\n  options.agent = new https.Agent(options);\r\n};\r\n\r\nmodule.exports = ClientSSLSecurityPFX;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/security/WSSecurity.js":"\"use strict\";\r\n\r\nvar crypto = require('crypto');\r\nvar passwordDigest = require('../utils').passwordDigest;\r\nvar validPasswordTypes = ['PasswordDigest', 'PasswordText'];\r\n\r\nfunction WSSecurity(username, password, options) {\r\n  options = options || {};\r\n  this._username = username;\r\n  this._password = password;\r\n  //must account for backward compatibility for passwordType String param as well as object options defaults: passwordType = 'PasswordText', hasTimeStamp = true   \r\n  if (typeof options === 'string') {\r\n    this._passwordType = options ? options : 'PasswordText';\r\n    options = {};\r\n  } else {\r\n    this._passwordType = options.passwordType ? options.passwordType : 'PasswordText';\r\n  }\r\n\r\n  if (validPasswordTypes.indexOf(this._passwordType) === -1) {\r\n    this._passwordType = 'PasswordText';\r\n  }\r\n\r\n  this._hasTimeStamp = options.hasTimeStamp || typeof options.hasTimeStamp === 'boolean' ? !!options.hasTimeStamp : true;\r\n  /*jshint eqnull:true */\r\n  if (options.hasNonce != null) {\r\n    this._hasNonce = !!options.hasNonce;\r\n  }\r\n  this._hasTokenCreated = options.hasTokenCreated || typeof options.hasTokenCreated === 'boolean' ? !!options.hasTokenCreated : true;\r\n  if (options.actor != null) {\r\n    this._actor = options.actor;\r\n  }\r\n  if (options.mustUnderstand != null) {\r\n    this._mustUnderstand = !!options.mustUnderstand;\r\n  }\r\n}\r\n\r\nWSSecurity.prototype.toXML = function() {\r\n  // avoid dependency on date formatting libraries\r\n  function getDate(d) {\r\n    function pad(n) {\r\n      return n < 10 ? '0' + n : n;\r\n    }\r\n    return d.getUTCFullYear() + '-'\r\n      + pad(d.getUTCMonth() + 1) + '-'\r\n      + pad(d.getUTCDate()) + 'T'\r\n      + pad(d.getUTCHours()) + ':'\r\n      + pad(d.getUTCMinutes()) + ':'\r\n      + pad(d.getUTCSeconds()) + 'Z';\r\n  }\r\n  var now = new Date();\r\n  var created = getDate(now);\r\n  var timeStampXml = '';\r\n  if (this._hasTimeStamp) {\r\n    var expires = getDate( new Date(now.getTime() + (1000 * 600)) );\r\n    timeStampXml = \"<wsu:Timestamp wsu:Id=\\\"Timestamp-\"+created+\"\\\">\" +\r\n      \"<wsu:Created>\"+created+\"</wsu:Created>\" +\r\n      \"<wsu:Expires>\"+expires+\"</wsu:Expires>\" +\r\n      \"</wsu:Timestamp>\";\r\n  }\r\n\r\n  var password, nonce;\r\n  if (this._hasNonce || this._passwordType !== 'PasswordText') {\r\n    // nonce = base64 ( sha1 ( created + random ) )\r\n    var nHash = crypto.createHash('sha1');\r\n    nHash.update(created + Math.random());\r\n    nonce = nHash.digest('base64');\r\n  }\r\n  if (this._passwordType === 'PasswordText') {\r\n    password = \"<wsse:Password Type=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\\\">\" + this._password + \"</wsse:Password>\";\r\n    if (nonce) {\r\n      password += \"<wsse:Nonce EncodingType=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\\\">\" + nonce + \"</wsse:Nonce>\";\r\n    }\r\n  } else {\r\n    password = \"<wsse:Password Type=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\\\">\" + passwordDigest(nonce, created, this._password) + \"</wsse:Password>\" +\r\n      \"<wsse:Nonce EncodingType=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\\\">\" + nonce + \"</wsse:Nonce>\";\r\n  }\r\n\r\n  return \"<wsse:Security \" + (this._actor ? \"soap:actor=\\\"\" + this._actor + \"\\\" \" : \"\") +\r\n    (this._mustUnderstand ? \"soap:mustUnderstand=\\\"1\\\" \" : \"\") +\r\n    \"xmlns:wsse=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\\\" xmlns:wsu=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\\\">\" +\r\n    timeStampXml +\r\n    \"<wsse:UsernameToken xmlns:wsu=\\\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\\\" wsu:Id=\\\"SecurityToken-\" + created + \"\\\">\" +\r\n    \"<wsse:Username>\" + this._username + \"</wsse:Username>\" +\r\n    password +\r\n    (this._hasTokenCreated ? \"<wsu:Created>\" + created + \"</wsu:Created>\" : \"\") +\r\n    \"</wsse:UsernameToken>\" +\r\n    \"</wsse:Security>\";\r\n};\r\n\r\nmodule.exports = WSSecurity;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/security/BearerSecurity.js":"\"use strict\";\r\n\r\nvar _ = require('lodash');\r\n\r\nfunction BearerSecurity(token, defaults) {\r\n\tthis._token = token;\r\n\tthis.defaults = {};\r\n\t_.merge(this.defaults, defaults);\r\n}\r\n\r\nBearerSecurity.prototype.addHeaders = function(headers) {\r\n\theaders.Authorization = \"Bearer \" + this._token;\r\n};\r\n\r\nBearerSecurity.prototype.toXML = function() {\r\n\treturn '';\r\n};\r\n\r\nBearerSecurity.prototype.addOptions = function(options) {\r\n  _.merge(options, this.defaults);\r\n};\r\n\r\nmodule.exports = BearerSecurity;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/security/WSSecurityCert.js":"\"use strict\";\r\n\r\nvar optional = require(\"optional\");\r\nvar ursa = optional('ursa');\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar ejs = require('ejs');\r\nvar SignedXml = require('xml-crypto').SignedXml;\r\nvar uuid = require('uuid');\r\nvar wsseSecurityHeaderTemplate = ejs.compile(fs.readFileSync(path.join(__dirname, 'templates', 'wsse-security-header.ejs')).toString());\r\nvar wsseSecurityTokenTemplate = ejs.compile(fs.readFileSync(path.join(__dirname, 'templates', 'wsse-security-token.ejs')).toString());\r\n\r\nfunction addMinutes(date, minutes) {\r\n  return new Date(date.getTime() + minutes * 60000);\r\n}\r\n\r\nfunction dateStringForSOAP(date) {\r\n  return date.getUTCFullYear() + '-' + ('0' + (date.getUTCMonth() + 1)).slice(-2) + '-' +\r\n    ('0' + date.getUTCDate()).slice(-2) + 'T' + ('0' + date.getUTCHours()).slice(-2) + \":\" +\r\n    ('0' + date.getUTCMinutes()).slice(-2) + \":\" + ('0' + date.getUTCSeconds()).slice(-2) + \"Z\";\r\n}\r\n\r\nfunction generateCreated() {\r\n  return dateStringForSOAP(new Date());\r\n}\r\n\r\nfunction generateExpires() {\r\n  return dateStringForSOAP(addMinutes(new Date(), 10));\r\n}\r\n\r\nfunction insertStr(src, dst, pos) {\r\n  return [dst.slice(0, pos), src, dst.slice(pos)].join('');\r\n}\r\n\r\nfunction generateId() {\r\n  return uuid.v4().replace(/-/gm, '');\r\n}\r\n\r\nfunction WSSecurityCert(privatePEM, publicP12PEM, password, encoding) {\r\n  if (!ursa) {\r\n    throw new Error('Module ursa must be installed to use WSSecurityCert');\r\n  }\r\n  this.privateKey = ursa.createPrivateKey(privatePEM, password, encoding);\r\n  this.publicP12PEM = publicP12PEM.toString().replace('-----BEGIN CERTIFICATE-----', '').replace('-----END CERTIFICATE-----', '').replace(/(\\r\\n|\\n|\\r)/gm, '');\r\n\r\n  this.signer = new SignedXml();\r\n  this.signer.signingKey = this.privateKey.toPrivatePem();\r\n  this.x509Id = \"x509-\" + generateId();\r\n\r\n  var _this = this;\r\n  this.signer.keyInfoProvider = {};\r\n  this.signer.keyInfoProvider.getKeyInfo = function (key) {\r\n    return wsseSecurityTokenTemplate({ x509Id: _this.x509Id });\r\n  };\r\n}\r\n\r\nWSSecurityCert.prototype.postProcess = function (xml, envelopeKey) {\r\n  this.created = generateCreated();\r\n  this.expires = generateExpires();\r\n\r\n  var secHeader = wsseSecurityHeaderTemplate({\r\n    binaryToken: this.publicP12PEM,\r\n    created: this.created,\r\n    expires: this.expires,\r\n    id: this.x509Id\r\n  });\r\n\r\n  var xmlWithSec = insertStr(secHeader, xml, xml.indexOf('</soap:Header>'));\r\n\r\n  var references = [\"http://www.w3.org/2000/09/xmldsig#enveloped-signature\",\r\n    \"http://www.w3.org/2001/10/xml-exc-c14n#\"];\r\n\r\n  this.signer.addReference(\"//*[name(.)='\" + envelopeKey + \":Body']\", references);\r\n  this.signer.addReference(\"//*[name(.)='wsse:Security']/*[local-name(.)='Timestamp']\", references);\r\n\r\n  this.signer.computeSignature(xmlWithSec);\r\n\r\n  return insertStr(this.signer.getSignatureXml(), xmlWithSec, xmlWithSec.indexOf('</wsse:Security>'));\r\n};\r\n\r\nmodule.exports = WSSecurityCert;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/wsdl.js":"/*\r\n * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>\r\n * MIT Licensed\r\n *\r\n */\r\n/*jshint proto:true*/\r\n\r\n\"use strict\";\r\n\r\nvar sax = require('sax');\r\nvar inherits = require('util').inherits;\r\nvar HttpClient = require('./http');\r\nvar NamespaceContext = require('./nscontext');\r\nvar fs = require('fs');\r\nvar url = require('url');\r\nvar path = require('path');\r\nvar assert = require('assert').ok;\r\nvar stripBom = require('strip-bom');\r\nvar debug = require('debug')('node-soap');\r\nvar _ = require('lodash');\r\nvar selectn = require('selectn');\r\nvar utils = require('./utils');\r\nvar TNS_PREFIX = utils.TNS_PREFIX;\r\nvar findPrefix = utils.findPrefix;\r\n\r\nvar Primitives = {\r\n  string: 1,\r\n  boolean: 1,\r\n  decimal: 1,\r\n  float: 1,\r\n  double: 1,\r\n  anyType: 1,\r\n  byte: 1,\r\n  int: 1,\r\n  long: 1,\r\n  short: 1,\r\n  negativeInteger: 1,\r\n  nonNegativeInteger: 1,\r\n  positiveInteger: 1,\r\n  nonPositiveInteger:1,\r\n  unsignedByte: 1,\r\n  unsignedInt: 1,\r\n  unsignedLong: 1,\r\n  unsignedShort: 1,\r\n  duration: 0,\r\n  dateTime: 0,\r\n  time: 0,\r\n  date: 0,\r\n  gYearMonth: 0,\r\n  gYear: 0,\r\n  gMonthDay: 0,\r\n  gDay: 0,\r\n  gMonth: 0,\r\n  hexBinary: 0,\r\n  base64Binary: 0,\r\n  anyURI: 0,\r\n  QName: 0,\r\n  NOTATION: 0\r\n};\r\n\r\nfunction splitQName(nsName) {\r\n  var i = typeof nsName === 'string' ? nsName.indexOf(':') : -1;\r\n  return i < 0 ? {prefix: TNS_PREFIX, name: nsName} :\r\n  {prefix: nsName.substring(0, i), name: nsName.substring(i + 1)};\r\n}\r\n\r\nfunction xmlEscape(obj) {\r\n  if (typeof (obj) === 'string') {\r\n    if (obj.substr(0,9) === '<![CDATA[' && obj.substr(-3) === \"]]>\") {\r\n      return obj;\r\n    }\r\n    return obj\r\n      .replace(/&/g, '&amp;')\r\n      .replace(/</g, '&lt;')\r\n      .replace(/>/g, '&gt;')\r\n      .replace(/\"/g, '&quot;')\r\n      .replace(/'/g, '&apos;');\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nvar trimLeft = /^[\\s\\xA0]+/;\r\nvar trimRight = /[\\s\\xA0]+$/;\r\n\r\nfunction trim(text) {\r\n  return text.replace(trimLeft, '').replace(trimRight, '');\r\n}\r\n\r\nfunction deepMerge(destination, source) {\r\n  return _.merge(destination || {}, source, function(a, b) {\r\n      return _.isArray(a) ? a.concat(b) : undefined;\r\n    });\r\n}\r\n\r\nvar Element = function(nsName, attrs, options) {\r\n  var parts = splitQName(nsName);\r\n\r\n  this.nsName = nsName;\r\n  this.prefix = parts.prefix;\r\n  this.name = parts.name;\r\n  this.children = [];\r\n  this.xmlns = {};\r\n\r\n  this._initializeOptions(options);\r\n\r\n  for (var key in attrs) {\r\n    var match = /^xmlns:?(.*)$/.exec(key);\r\n    if (match) {\r\n      this.xmlns[match[1] ? match[1] : TNS_PREFIX] = attrs[key];\r\n    }\r\n    else {\r\n      if(key === 'value') {\r\n        this[this.valueKey] = attrs[key];\r\n      } else {\r\n        this['$' + key] = attrs[key];\r\n      }\r\n    }\r\n  }\r\n  if (this.$targetNamespace !== undefined) {\r\n    // Add targetNamespace to the mapping\r\n    this.xmlns[TNS_PREFIX] = this.$targetNamespace;\r\n  }\r\n};\r\n\r\nElement.prototype._initializeOptions = function (options) {\r\n  if(options) {\r\n    this.valueKey = options.valueKey || '$value';\r\n    this.xmlKey = options.xmlKey || '$xml';\r\n    this.ignoredNamespaces = options.ignoredNamespaces || [];\r\n  } else {\r\n    this.valueKey = '$value';\r\n    this.xmlKey = '$xml';\r\n    this.ignoredNamespaces = [];\r\n  }\r\n};\r\n\r\nElement.prototype.deleteFixedAttrs = function() {\r\n  this.children && this.children.length === 0 && delete this.children;\r\n  this.xmlns && Object.keys(this.xmlns).length === 0 && delete this.xmlns;\r\n  delete this.nsName;\r\n  delete this.prefix;\r\n  delete this.name;\r\n};\r\n\r\nElement.prototype.allowedChildren = [];\r\n\r\nElement.prototype.startElement = function(stack, nsName, attrs, options) {\r\n  if (!this.allowedChildren) {\r\n    return;\r\n  }\r\n\r\n  var ChildClass = this.allowedChildren[splitQName(nsName).name],\r\n    element = null;\r\n\r\n  if (ChildClass) {\r\n    stack.push(new ChildClass(nsName, attrs, options));\r\n  }\r\n  else {\r\n    this.unexpected(nsName);\r\n  }\r\n\r\n};\r\n\r\nElement.prototype.endElement = function(stack, nsName) {\r\n  if (this.nsName === nsName) {\r\n    if (stack.length < 2)\r\n      return;\r\n    var parent = stack[stack.length - 2];\r\n    if (this !== stack[0]) {\r\n      _.defaultsDeep(stack[0].xmlns, this.xmlns);\r\n      // delete this.xmlns;\r\n      parent.children.push(this);\r\n      parent.addChild(this);\r\n    }\r\n    stack.pop();\r\n  }\r\n};\r\n\r\nElement.prototype.addChild = function(child) {\r\n  return;\r\n};\r\n\r\nElement.prototype.unexpected = function(name) {\r\n  throw new Error('Found unexpected element (' + name + ') inside ' + this.nsName);\r\n};\r\n\r\nElement.prototype.description = function(definitions) {\r\n  return this.$name || this.name;\r\n};\r\n\r\nElement.prototype.init = function() {\r\n};\r\n\r\nElement.createSubClass = function() {\r\n  var root = this;\r\n  var subElement = function() {\r\n    root.apply(this, arguments);\r\n    this.init();\r\n  };\r\n  // inherits(subElement, root);\r\n  subElement.prototype.__proto__ = root.prototype;\r\n  return subElement;\r\n};\r\n\r\n\r\nvar ElementElement = Element.createSubClass();\r\nvar AnyElement = Element.createSubClass();\r\nvar InputElement = Element.createSubClass();\r\nvar OutputElement = Element.createSubClass();\r\nvar SimpleTypeElement = Element.createSubClass();\r\nvar RestrictionElement = Element.createSubClass();\r\nvar ExtensionElement = Element.createSubClass();\r\nvar ChoiceElement = Element.createSubClass();\r\nvar EnumerationElement = Element.createSubClass();\r\nvar ComplexTypeElement = Element.createSubClass();\r\nvar ComplexContentElement = Element.createSubClass();\r\nvar SimpleContentElement = Element.createSubClass();\r\nvar SequenceElement = Element.createSubClass();\r\nvar AllElement = Element.createSubClass();\r\nvar MessageElement = Element.createSubClass();\r\nvar DocumentationElement = Element.createSubClass();\r\n\r\nvar SchemaElement = Element.createSubClass();\r\nvar TypesElement = Element.createSubClass();\r\nvar OperationElement = Element.createSubClass();\r\nvar PortTypeElement = Element.createSubClass();\r\nvar BindingElement = Element.createSubClass();\r\nvar PortElement = Element.createSubClass();\r\nvar ServiceElement = Element.createSubClass();\r\nvar DefinitionsElement = Element.createSubClass();\r\n\r\nvar ElementTypeMap = {\r\n  types: [TypesElement, 'schema documentation'],\r\n  schema: [SchemaElement, 'element complexType simpleType include import'],\r\n  element: [ElementElement, 'annotation complexType'],\r\n  any: [AnyElement, ''],\r\n  simpleType: [SimpleTypeElement, 'restriction'],\r\n  restriction: [RestrictionElement, 'enumeration all choice sequence'],\r\n  extension: [ExtensionElement, 'all sequence choice'],\r\n  choice: [ChoiceElement, 'element sequence choice any'],\r\n    // group: [GroupElement, 'element group'],\r\n  enumeration: [EnumerationElement, ''],\r\n  complexType: [ComplexTypeElement,  'annotation sequence all complexContent simpleContent choice'],\r\n  complexContent: [ComplexContentElement,  'extension'],\r\n  simpleContent: [SimpleContentElement,  'extension'],\r\n  sequence: [SequenceElement, 'element sequence choice any'],\r\n  all: [AllElement, 'element choice'],\r\n\r\n  service: [ServiceElement, 'port documentation'],\r\n  port: [PortElement, 'address documentation'],\r\n  binding: [BindingElement, '_binding SecuritySpec operation documentation'],\r\n  portType: [PortTypeElement, 'operation documentation'],\r\n  message: [MessageElement, 'part documentation'],\r\n  operation: [OperationElement, 'documentation input output fault _operation'],\r\n  input: [InputElement, 'body SecuritySpecRef documentation header'],\r\n  output: [OutputElement, 'body SecuritySpecRef documentation header'],\r\n  fault: [Element, '_fault documentation'],\r\n  definitions: [DefinitionsElement, 'types message portType binding service import documentation'],\r\n  documentation: [DocumentationElement, '']\r\n};\r\n\r\nfunction mapElementTypes(types) {\r\n  var rtn = {};\r\n  types = types.split(' ');\r\n  types.forEach(function(type) {\r\n    rtn[type.replace(/^_/, '')] = (ElementTypeMap[type] || [Element]) [0];\r\n  });\r\n  return rtn;\r\n}\r\n\r\nfor (var n in ElementTypeMap) {\r\n  var v = ElementTypeMap[n];\r\n  v[0].prototype.allowedChildren = mapElementTypes(v[1]);\r\n}\r\n\r\nMessageElement.prototype.init = function() {\r\n  this.element = null;\r\n  this.parts = null;\r\n};\r\n\r\nSchemaElement.prototype.init = function() {\r\n  this.complexTypes = {};\r\n  this.types = {};\r\n  this.elements = {};\r\n  this.includes = [];\r\n};\r\n\r\nTypesElement.prototype.init = function() {\r\n  this.schemas = {};\r\n};\r\n\r\nOperationElement.prototype.init = function() {\r\n  this.input = null;\r\n  this.output = null;\r\n  this.inputSoap = null;\r\n  this.outputSoap = null;\r\n  this.style = '';\r\n  this.soapAction = '';\r\n};\r\n\r\nPortTypeElement.prototype.init = function() {\r\n  this.methods = {};\r\n};\r\n\r\nBindingElement.prototype.init = function() {\r\n  this.transport = '';\r\n  this.style = '';\r\n  this.methods = {};\r\n};\r\n\r\nPortElement.prototype.init = function() {\r\n  this.location = null;\r\n};\r\n\r\nServiceElement.prototype.init = function() {\r\n  this.ports = {};\r\n};\r\n\r\nDefinitionsElement.prototype.init = function() {\r\n  if (this.name !== 'definitions')this.unexpected(this.nsName);\r\n  this.messages = {};\r\n  this.portTypes = {};\r\n  this.bindings = {};\r\n  this.services = {};\r\n  this.schemas = {};\r\n};\r\n\r\nDocumentationElement.prototype.init = function() {\r\n};\r\n\r\nSchemaElement.prototype.merge = function(source) {\r\n  assert(source instanceof SchemaElement);\r\n  if (this.$targetNamespace === source.$targetNamespace) {\r\n    _.merge(this.complexTypes, source.complexTypes);\r\n    _.merge(this.types, source.types);\r\n    _.merge(this.elements, source.elements);\r\n    _.merge(this.xmlns, source.xmlns);\r\n  }\r\n  return this;\r\n};\r\n\r\n\r\nSchemaElement.prototype.addChild = function(child) {\r\n  if (child.$name in Primitives)\r\n    return;\r\n  if (child.name === 'include' || child.name === 'import') {\r\n    var location = child.$schemaLocation || child.$location;\r\n    if (location) {\r\n      this.includes.push({\r\n        namespace: child.$namespace || child.$targetNamespace || this.$targetNamespace,\r\n        location: location\r\n      });\r\n    }\r\n  }\r\n  else if (child.name === 'complexType') {\r\n    this.complexTypes[child.$name] = child;\r\n  }\r\n  else if (child.name === 'element') {\r\n    this.elements[child.$name] = child;\r\n  }\r\n  else if (child.$name) {\r\n    this.types[child.$name] = child;\r\n  }\r\n  this.children.pop();\r\n  // child.deleteFixedAttrs();\r\n};\r\n//fix#325\r\nTypesElement.prototype.addChild = function (child) {\r\n  assert(child instanceof SchemaElement);\r\n\r\n  var targetNamespace = child.$targetNamespace;\r\n\r\n  if(!this.schemas.hasOwnProperty(targetNamespace)) {\r\n    this.schemas[targetNamespace] = child;\r\n  } else {\r\n    console.error('Target-Namespace \"'+ targetNamespace +'\" already in use by another Schema!');\r\n  }\r\n};\r\n\r\nInputElement.prototype.addChild = function(child) {\r\n  if (child.name === 'body') {\r\n    this.use = child.$use;\r\n    if (this.use === 'encoded') {\r\n      this.encodingStyle = child.$encodingStyle;\r\n    }\r\n    this.children.pop();\r\n  }\r\n};\r\n\r\nOutputElement.prototype.addChild = function(child) {\r\n  if (child.name === 'body') {\r\n    this.use = child.$use;\r\n    if (this.use === 'encoded') {\r\n      this.encodingStyle = child.$encodingStyle;\r\n    }\r\n    this.children.pop();\r\n  }\r\n};\r\n\r\nOperationElement.prototype.addChild = function(child) {\r\n  if (child.name === 'operation') {\r\n    this.soapAction = child.$soapAction || '';\r\n    this.style = child.$style || '';\r\n    this.children.pop();\r\n  }\r\n};\r\n\r\nBindingElement.prototype.addChild = function(child) {\r\n  if (child.name === 'binding') {\r\n    this.transport = child.$transport;\r\n    this.style = child.$style;\r\n    this.children.pop();\r\n  }\r\n};\r\n\r\nPortElement.prototype.addChild = function(child) {\r\n  if (child.name === 'address' && typeof (child.$location) !== 'undefined') {\r\n    this.location = child.$location;\r\n  }\r\n};\r\n\r\nDefinitionsElement.prototype.addChild = function(child) {\r\n  var self = this;\r\n  if (child instanceof TypesElement) {\r\n    // Merge types.schemas into definitions.schemas\r\n    _.merge(self.schemas, child.schemas);\r\n  }\r\n  else if (child instanceof MessageElement) {\r\n    self.messages[child.$name] = child;\r\n  }\r\n  else if (child.name === 'import') {\r\n    self.schemas[child.$namespace] = new SchemaElement(child.$namespace, {});\r\n    self.schemas[child.$namespace].addChild(child);\r\n  }\r\n  else if (child instanceof PortTypeElement) {\r\n    self.portTypes[child.$name] = child;\r\n  }\r\n  else if (child instanceof BindingElement) {\r\n    if (child.transport === 'http://schemas.xmlsoap.org/soap/http' ||\r\n      child.transport === 'http://www.w3.org/2003/05/soap/bindings/HTTP/')\r\n      self.bindings[child.$name] = child;\r\n  }\r\n  else if (child instanceof ServiceElement) {\r\n    self.services[child.$name] = child;\r\n  }\r\n  else if (child instanceof DocumentationElement) {\r\n  }\r\n  this.children.pop();\r\n};\r\n\r\nMessageElement.prototype.postProcess = function(definitions) {\r\n  var part = null;\r\n  var child;\r\n  var children = this.children || [];\r\n  var ns;\r\n  var nsName;\r\n  var i;\r\n  var type;\r\n\r\n  for (i in children) {\r\n    if ((child = children[i]).name === 'part') {\r\n      part = child;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (!part) {\r\n    return;\r\n  }\r\n\r\n  if (part.$element) {\r\n    var lookupTypes = [],\r\n        elementChildren ;\r\n\r\n    delete this.parts;\r\n\r\n    nsName = splitQName(part.$element);\r\n    ns = nsName.prefix;\r\n    var schema = definitions.schemas[definitions.xmlns[ns]];\r\n    this.element = schema.elements[nsName.name];\r\n    if(!this.element) {\r\n      debug(nsName.name + \" is not present in wsdl and cannot be processed correctly.\");\r\n      return;\r\n    }\r\n    this.element.targetNSAlias = ns;\r\n    this.element.targetNamespace = definitions.xmlns[ns];\r\n\r\n    // set the optional $lookupType to be used within `client#_invoke()` when\r\n    // calling `wsdl#objectToDocumentXML()\r\n    this.element.$lookupType = part.$element;\r\n\r\n    elementChildren = this.element.children;\r\n\r\n    // get all nested lookup types (only complex types are followed)\r\n    if (elementChildren.length > 0) {\r\n      for (i = 0; i < elementChildren.length; i++) {\r\n        lookupTypes.push(this._getNestedLookupTypeString(elementChildren[i]));\r\n      }\r\n    }\r\n\r\n    // if nested lookup types where found, prepare them for furter usage\r\n    if (lookupTypes.length > 0) {\r\n      lookupTypes = lookupTypes.\r\n          join('_').\r\n          split('_').\r\n          filter(function removeEmptyLookupTypes (type) {\r\n            return type !== '^';\r\n          });\r\n\r\n      var schemaXmlns = definitions.schemas[this.element.targetNamespace].xmlns;\r\n\r\n      for (i = 0; i < lookupTypes.length; i++) {\r\n        lookupTypes[i] = this._createLookupTypeObject(lookupTypes[i], schemaXmlns);\r\n      }\r\n    }\r\n\r\n    this.element.$lookupTypes = lookupTypes;\r\n\r\n    if (this.element.$type) {\r\n      type = splitQName(this.element.$type);\r\n      var typeNs = schema.xmlns && schema.xmlns[type.prefix] || definitions.xmlns[type.prefix];\r\n\r\n      if (typeNs) {\r\n        if (type.name in Primitives) {\r\n            // this.element = this.element.$type;\r\n        }\r\n        else {\r\n          // first check local mapping of ns alias to namespace\r\n          schema = definitions.schemas[typeNs];\r\n          var ctype = schema.complexTypes[type.name] || schema.types[type.name] || schema.elements[type.name];\r\n\r\n\r\n          if (ctype) {\r\n            this.parts = ctype.description(definitions, schema.xmlns);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      var method = this.element.description(definitions, schema.xmlns);\r\n      this.parts = method[nsName.name];\r\n    }\r\n\r\n\r\n    this.children.splice(0, 1);\r\n  } else {\r\n    // rpc encoding\r\n    this.parts = {};\r\n    delete this.element;\r\n    for (i = 0; part = this.children[i]; i++) {\r\n      if (part.name === 'documentation') {\r\n        // <wsdl:documentation can be present under <wsdl:message>\r\n        continue;\r\n      }\r\n      assert(part.name === 'part', 'Expected part element');\r\n      nsName = splitQName(part.$type);\r\n      ns = definitions.xmlns[nsName.prefix];\r\n      type = nsName.name;\r\n      var schemaDefinition = definitions.schemas[ns];\r\n      if (typeof schemaDefinition !== 'undefined') {\r\n        this.parts[part.$name] = definitions.schemas[ns].types[type] || definitions.schemas[ns].complexTypes[type];\r\n      } else {\r\n        this.parts[part.$name] = part.$type;\r\n      }\r\n\r\n      if (typeof this.parts[part.$name] === 'object') {\r\n        this.parts[part.$name].prefix = nsName.prefix;\r\n        this.parts[part.$name].xmlns = ns;\r\n      }\r\n\r\n      this.children.splice(i--, 1);\r\n    }\r\n  }\r\n  this.deleteFixedAttrs();\r\n};\r\n\r\n/**\r\n * Takes a given namespaced String(for example: 'alias:property') and creates a lookupType\r\n * object for further use in as first (lookup) `parameterTypeObj` within the `objectToXML`\r\n * method and provides an entry point for the already existing code in `findChildSchemaObject`.\r\n *\r\n * @method _createLookupTypeObject\r\n * @param {String}            nsString          The NS String (for example \"alias:type\").\r\n * @param {Object}            xmlns       The fully parsed `wsdl` definitions object (including all schemas).\r\n * @returns {Object}\r\n * @private\r\n */\r\nMessageElement.prototype._createLookupTypeObject = function (nsString, xmlns) {\r\n  var splittedNSString = splitQName(nsString),\r\n      nsAlias = splittedNSString.prefix,\r\n      splittedName = splittedNSString.name.split('#'),\r\n      type = splittedName[0],\r\n      name = splittedName[1],\r\n      lookupTypeObj = {};\r\n\r\n  lookupTypeObj.$namespace = xmlns[nsAlias];\r\n  lookupTypeObj.$type = nsAlias + ':' + type;\r\n  lookupTypeObj.$name = name;\r\n\r\n  return lookupTypeObj;\r\n};\r\n\r\n/**\r\n * Iterates through the element and every nested child to find any defined `$type`\r\n * property and returns it in a underscore ('_') separated String (using '^' as default\r\n * value if no `$type` property was found).\r\n *\r\n * @method _getNestedLookupTypeString\r\n * @param {Object}            element         The element which (probably) contains nested `$type` values.\r\n * @returns {String}\r\n * @private\r\n */\r\nMessageElement.prototype._getNestedLookupTypeString = function (element) {\r\n  var resolvedType = '^',\r\n      excluded = this.ignoredNamespaces.concat('xs'); // do not process $type values wich start with\r\n\r\n  if (element.hasOwnProperty('$type') && typeof element.$type === 'string') {\r\n    if (excluded.indexOf(element.$type.split(':')[0]) === -1) {\r\n      resolvedType += ('_' + element.$type + '#' + element.$name);\r\n    }\r\n  }\r\n\r\n  if (element.children.length > 0) {\r\n    var self = this;\r\n\r\n    element.children.forEach(function (child) {\r\n      var resolvedChildType = self._getNestedLookupTypeString(child).replace(/\\^_/, '');\r\n\r\n      if (resolvedChildType && typeof resolvedChildType === 'string') {\r\n        resolvedType += ('_' + resolvedChildType);\r\n      }\r\n    });\r\n  }\r\n\r\n  return resolvedType;\r\n};\r\n\r\nOperationElement.prototype.postProcess = function(definitions, tag) {\r\n  var children = this.children;\r\n  for (var i = 0, child; child = children[i]; i++) {\r\n    if (child.name !== 'input' && child.name !== 'output')\r\n      continue;\r\n    if (tag === 'binding') {\r\n      this[child.name] = child;\r\n      children.splice(i--, 1);\r\n      continue;\r\n    }\r\n    var messageName = splitQName(child.$message).name;\r\n    var message = definitions.messages[messageName];\r\n    message.postProcess(definitions);\r\n    if (message.element) {\r\n      definitions.messages[message.element.$name] = message;\r\n      this[child.name] = message.element;\r\n    }\r\n    else {\r\n      this[child.name] = message;\r\n    }\r\n    children.splice(i--, 1);\r\n  }\r\n  this.deleteFixedAttrs();\r\n};\r\n\r\nPortTypeElement.prototype.postProcess = function(definitions) {\r\n  var children = this.children;\r\n  if (typeof children === 'undefined')\r\n    return;\r\n  for (var i = 0, child; child = children[i]; i++) {\r\n    if (child.name !== 'operation')\r\n      continue;\r\n    child.postProcess(definitions, 'portType');\r\n    this.methods[child.$name] = child;\r\n    children.splice(i--, 1);\r\n  }\r\n  delete this.$name;\r\n  this.deleteFixedAttrs();\r\n};\r\n\r\nBindingElement.prototype.postProcess = function(definitions) {\r\n  var type = splitQName(this.$type).name,\r\n    portType = definitions.portTypes[type],\r\n    style = this.style,\r\n    children = this.children;\r\n  if (portType){\r\n    portType.postProcess(definitions);\r\n    this.methods = portType.methods;\r\n\r\n    for (var i = 0, child; child = children[i]; i++) {\r\n      if (child.name !== 'operation')\r\n        continue;\r\n      child.postProcess(definitions, 'binding');\r\n      children.splice(i--, 1);\r\n      child.style || (child.style = style);\r\n      var method = this.methods[child.$name];\r\n\r\n      if (method) {\r\n        method.style = child.style;\r\n        method.soapAction = child.soapAction;\r\n        method.inputSoap = child.input || null;\r\n        method.outputSoap = child.output || null;\r\n        method.inputSoap && method.inputSoap.deleteFixedAttrs();\r\n        method.outputSoap && method.outputSoap.deleteFixedAttrs();\r\n      }\r\n    }\r\n  }\r\n  delete this.$name;\r\n  delete this.$type;\r\n  this.deleteFixedAttrs();\r\n};\r\n\r\nServiceElement.prototype.postProcess = function(definitions) {\r\n  var children = this.children,\r\n    bindings = definitions.bindings;\r\n  if (children && children.length > 0) {\r\n    for (var i = 0, child; child = children[i]; i++) {\r\n      if (child.name !== 'port')\r\n        continue;\r\n      var bindingName = splitQName(child.$binding).name;\r\n      var binding = bindings[bindingName];\r\n      if (binding) {\r\n        binding.postProcess(definitions);\r\n        this.ports[child.$name] = {\r\n          location: child.location,\r\n          binding: binding\r\n        };\r\n        children.splice(i--, 1);\r\n      }\r\n    }\r\n  }\r\n  delete this.$name;\r\n  this.deleteFixedAttrs();\r\n};\r\n\r\n\r\nSimpleTypeElement.prototype.description = function(definitions) {\r\n  var children = this.children;\r\n  for (var i = 0, child; child = children[i]; i++) {\r\n    if (child instanceof RestrictionElement)\r\n      return this.$name + \"|\" + child.description();\r\n  }\r\n  return {};\r\n};\r\n\r\nRestrictionElement.prototype.description = function(definitions, xmlns) {\r\n  var children = this.children;\r\n  var desc;\r\n  for (var i=0, child; child=children[i]; i++) {\r\n    if (child instanceof SequenceElement ||\r\n            child instanceof ChoiceElement) {\r\n      desc = child.description(definitions, xmlns);\r\n      break;\r\n    }\r\n  }\r\n  if (desc && this.$base) {\r\n    var type = splitQName(this.$base),\r\n      typeName = type.name,\r\n      ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\r\n      schema = definitions.schemas[ns],\r\n      typeElement = schema && ( schema.complexTypes[typeName] || schema.types[typeName] || schema.elements[typeName] );\r\n\r\n    desc.getBase = function() {\r\n      return typeElement.description(definitions, schema.xmlns);\r\n    };\r\n    return desc;\r\n  }\r\n\r\n    // then simple element\r\n  var base = this.$base ? this.$base + \"|\" : \"\";\r\n  return base + this.children.map(function(child) {\r\n    return child.description();\r\n  }).join(\",\");\r\n};\r\n\r\nExtensionElement.prototype.description = function(definitions, xmlns) {\r\n  var children = this.children;\r\n  var desc = {};\r\n  for (var i=0, child; child=children[i]; i++) {\r\n    if (child instanceof SequenceElement ||\r\n      child instanceof ChoiceElement) {\r\n      desc = child.description(definitions, xmlns);\r\n    }\r\n  }\r\n  if (this.$base) {\r\n    var type = splitQName(this.$base),\r\n      typeName = type.name,\r\n      ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\r\n      schema = definitions.schemas[ns];\r\n\r\n    if (typeName in Primitives) {\r\n      return this.$base;\r\n    }\r\n    else {\r\n      var typeElement = schema && ( schema.complexTypes[typeName] ||\r\n        schema.types[typeName] || schema.elements[typeName] );\r\n\r\n      if (typeElement) {\r\n        var base = typeElement.description(definitions, schema.xmlns);\r\n        desc = _.defaultsDeep(base, desc);\r\n      }\r\n    }\r\n  }\r\n  return desc;\r\n};\r\n\r\nEnumerationElement.prototype.description = function() {\r\n  return this[this.valueKey];\r\n};\r\n\r\nComplexTypeElement.prototype.description = function(definitions, xmlns) {\r\n  var children = this.children || [];\r\n  for (var i=0, child; child=children[i]; i++) {\r\n    if (child instanceof ChoiceElement ||\r\n      child instanceof SequenceElement ||\r\n      child instanceof AllElement ||\r\n      child instanceof SimpleContentElement ||\r\n      child instanceof ComplexContentElement) {\r\n\r\n      return child.description(definitions, xmlns);\r\n    }\r\n  }\r\n  return {};\r\n};\r\n\r\nComplexContentElement.prototype.description = function(definitions, xmlns) {\r\n  var children = this.children;\r\n  for (var i = 0, child; child = children[i]; i++) {\r\n    if (child instanceof ExtensionElement) {\r\n      return child.description(definitions, xmlns);\r\n    }\r\n  }\r\n  return {};\r\n};\r\n\r\nSimpleContentElement.prototype.description = function(definitions, xmlns) {\r\n  var children = this.children;\r\n  for (var i = 0, child; child = children[i]; i++) {\r\n    if (child instanceof ExtensionElement) {\r\n      return child.description(definitions, xmlns);\r\n    }\r\n  }\r\n  return {};\r\n};\r\n\r\nElementElement.prototype.description = function(definitions, xmlns) {\r\n  var element = {},\r\n    name = this.$name;\r\n  var isMany = !this.$maxOccurs ? false : (isNaN(this.$maxOccurs) ? (this.$maxOccurs === 'unbounded') : (this.$maxOccurs > 1));\r\n  if (this.$minOccurs !== this.$maxOccurs && isMany) {\r\n    name += '[]';\r\n  }\r\n\r\n  if (xmlns && xmlns[TNS_PREFIX]) {\r\n    this.$targetNamespace = xmlns[TNS_PREFIX];\r\n  }\r\n  var type = this.$type || this.$ref;\r\n  if (type) {\r\n    type = splitQName(type);\r\n    var typeName = type.name,\r\n      ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix],\r\n      schema = definitions.schemas[ns],\r\n      typeElement = schema && ( this.$type? schema.complexTypes[typeName] || schema.types[typeName] : schema.elements[typeName] );\r\n\r\n    if (ns && definitions.schemas[ns]) {\r\n      xmlns = definitions.schemas[ns].xmlns;\r\n    }\r\n\r\n    if (typeElement && !(typeName in Primitives)) {\r\n\r\n      if (!(typeName in definitions.descriptions.types)) {\r\n\r\n        var elem = {};\r\n        definitions.descriptions.types[typeName] = elem;\r\n        var description = typeElement.description(definitions, xmlns);\r\n        if (typeof description === 'string') {\r\n          elem = description;\r\n        }\r\n        else {\r\n          Object.keys(description).forEach(function (key) {\r\n            elem[key] = description[key];\r\n          });\r\n        }\r\n\r\n        if (this.$ref) {\r\n          element = elem;\r\n        }\r\n        else {\r\n          element[name] = elem;\r\n        }\r\n\r\n        if (typeof elem === 'object') {\r\n          elem.targetNSAlias = type.prefix;\r\n          elem.targetNamespace = ns;\r\n        }\r\n\r\n        definitions.descriptions.types[typeName] = elem;\r\n      }\r\n      else {\r\n        if (this.$ref) {\r\n          element = definitions.descriptions.types[typeName];\r\n        }\r\n        else {\r\n          element[name] = definitions.descriptions.types[typeName];\r\n        }\r\n      }\r\n\r\n    }\r\n    else {\r\n      element[name] = this.$type;\r\n    }\r\n  }\r\n  else {\r\n    var children = this.children;\r\n    element[name] = {};\r\n    for (var i = 0, child; child = children[i]; i++) {\r\n      if (child instanceof ComplexTypeElement) {\r\n        element[name] = child.description(definitions, xmlns);\r\n      }\r\n    }\r\n  }\r\n  return element;\r\n};\r\n\r\nAllElement.prototype.description =\r\nSequenceElement.prototype.description = function(definitions, xmlns) {\r\n  var children = this.children;\r\n  var sequence = {};\r\n  for (var i = 0, child; child = children[i]; i++) {\r\n    if (child instanceof AnyElement) {\r\n      continue;\r\n    }\r\n    var description = child.description(definitions, xmlns);\r\n    for (var key in description) {\r\n      sequence[key] = description[key];\r\n    }\r\n  }\r\n  return sequence;\r\n};\r\n\r\nChoiceElement.prototype.description = function(definitions, xmlns) {\r\n  var children = this.children;\r\n  var choice = {};\r\n  for (var i=0, child; child=children[i]; i++) {\r\n    var description = child.description(definitions, xmlns);\r\n    for (var key in description) {\r\n      choice[key] = description[key];\r\n    }\r\n  }\r\n  return choice;\r\n};\r\n\r\nMessageElement.prototype.description = function(definitions) {\r\n  if (this.element) {\r\n    return this.element && this.element.description(definitions);\r\n  }\r\n  var desc = {};\r\n  desc[this.$name] = this.parts;\r\n  return desc;\r\n};\r\n\r\nPortTypeElement.prototype.description = function(definitions) {\r\n  var methods = {};\r\n  for (var name in this.methods) {\r\n    var method = this.methods[name];\r\n    methods[name] = method.description(definitions);\r\n  }\r\n  return methods;\r\n};\r\n\r\nOperationElement.prototype.description = function(definitions) {\r\n  var inputDesc = this.input ? this.input.description(definitions) : null;\r\n  var outputDesc = this.output ? this.output.description(definitions) : null;\r\n  return {\r\n    input: inputDesc && inputDesc[Object.keys(inputDesc)[0]],\r\n    output: outputDesc && outputDesc[Object.keys(outputDesc)[0]]\r\n  };\r\n};\r\n\r\nBindingElement.prototype.description = function(definitions) {\r\n  var methods = {};\r\n  for (var name in this.methods) {\r\n    var method = this.methods[name];\r\n    methods[name] = method.description(definitions);\r\n  }\r\n  return methods;\r\n};\r\n\r\nServiceElement.prototype.description = function(definitions) {\r\n  var ports = {};\r\n  for (var name in this.ports) {\r\n    var port = this.ports[name];\r\n    ports[name] = port.binding.description(definitions);\r\n  }\r\n  return ports;\r\n};\r\n\r\nvar WSDL = function(definition, uri, options) {\r\n  var self = this,\r\n      fromFunc;\r\n\r\n  this.uri = uri;\r\n  this.callback = function() {\r\n  };\r\n  this._includesWsdl = [];\r\n\r\n  // initialize WSDL cache\r\n  this.WSDL_CACHE = (options || {}).WSDL_CACHE || {};\r\n\r\n  this._initializeOptions(options);\r\n\r\n  if (typeof definition === 'string') {\r\n    definition = stripBom(definition);\r\n    fromFunc = this._fromXML;\r\n  }\r\n  else if (typeof definition === 'object') {\r\n    fromFunc = this._fromServices;\r\n  }\r\n  else {\r\n    throw new Error('WSDL constructor takes either an XML string or service definition');\r\n  }\r\n\r\n  process.nextTick(function() {\r\n    try {\r\n      fromFunc.call(self, definition);\r\n    } catch (e) {\r\n      return self.callback(e.message);\r\n    }\r\n\r\n    self.processIncludes(function(err) {\r\n      var name;\r\n      if (err) {\r\n        return self.callback(err);\r\n      }\r\n\r\n      self.definitions.deleteFixedAttrs();\r\n      var services = self.services = self.definitions.services;\r\n      if (services) {\r\n        for (name in services) {\r\n          services[name].postProcess(self.definitions);\r\n        }\r\n      }\r\n      var complexTypes = self.definitions.complexTypes;\r\n      if (complexTypes) {\r\n        for (name in complexTypes) {\r\n          complexTypes[name].deleteFixedAttrs();\r\n        }\r\n      }\r\n\r\n      // for document style, for every binding, prepare input message element name to (methodName, output message element name) mapping\r\n      var bindings = self.definitions.bindings;\r\n      for (var bindingName in bindings) {\r\n        var binding = bindings[bindingName];\r\n        if (typeof binding.style === 'undefined') {\r\n          binding.style = 'document';\r\n        }\r\n        if (binding.style !== 'document')\r\n          continue;\r\n        var methods = binding.methods;\r\n        var topEls = binding.topElements = {};\r\n        for (var methodName in methods) {\r\n          if (methods[methodName].input) {\r\n            var inputName = methods[methodName].input.$name;\r\n            var outputName=\"\";\r\n            if(methods[methodName].output )\r\n              outputName = methods[methodName].output.$name;\r\n            topEls[inputName] = {\"methodName\": methodName, \"outputName\": outputName};\r\n          }\r\n        }\r\n      }\r\n\r\n      // prepare soap envelope xmlns definition string\r\n      self.xmlnsInEnvelope = self._xmlnsMap();\r\n\r\n      self.callback(err, self);\r\n    });\r\n\r\n  });\r\n};\r\n\r\nWSDL.prototype.ignoredNamespaces = ['tns', 'targetNamespace', 'typedNamespace'];\r\n\r\nWSDL.prototype.ignoreBaseNameSpaces = false;\r\n\r\nWSDL.prototype.valueKey = '$value';\r\nWSDL.prototype.xmlKey = '$xml';\r\n\r\nWSDL.prototype._initializeOptions = function (options) {\r\n  this._originalIgnoredNamespaces = (options || {}).ignoredNamespaces;\r\n  this.options = {};\r\n\r\n  var ignoredNamespaces = options ? options.ignoredNamespaces : null;\r\n\r\n  if (ignoredNamespaces &&\r\n      (Array.isArray(ignoredNamespaces.namespaces) || typeof ignoredNamespaces.namespaces === 'string')) {\r\n    if (ignoredNamespaces.override) {\r\n      this.options.ignoredNamespaces = ignoredNamespaces.namespaces;\r\n    } else {\r\n      this.options.ignoredNamespaces = this.ignoredNamespaces.concat(ignoredNamespaces.namespaces);\r\n    }\r\n  } else {\r\n    this.options.ignoredNamespaces = this.ignoredNamespaces;\r\n  }\r\n\r\n  this.options.valueKey = options.valueKey || this.valueKey;\r\n  this.options.xmlKey = options.xmlKey || this.xmlKey;\r\n  if (options.escapeXML !== undefined) {\r\n    this.options.escapeXML = options.escapeXML;\r\n  } else {\r\n    this.options.escapeXML = true;\r\n  }\r\n  // Allow any request headers to keep passing through\r\n  this.options.wsdl_headers = options.wsdl_headers;\r\n  this.options.wsdl_options = options.wsdl_options;\r\n  if (options.httpClient) {\r\n    this.options.httpClient = options.httpClient;\r\n  }\r\n\r\n  // The supplied request-object should be passed through\r\n  if (options.request) {\r\n    this.options.request = options.request;\r\n  }\r\n\r\n  var ignoreBaseNameSpaces = options ? options.ignoreBaseNameSpaces : null;\r\n  if (ignoreBaseNameSpaces !== null && typeof ignoreBaseNameSpaces !== 'undefined') {\r\n    this.options.ignoreBaseNameSpaces = ignoreBaseNameSpaces;\r\n  } else {\r\n    this.options.ignoreBaseNameSpaces = this.ignoreBaseNameSpaces;\r\n  }\r\n\r\n  // Works only in client\r\n  this.options.forceSoap12Headers = options.forceSoap12Headers;\r\n  this.options.customDeserializer = options.customDeserializer;\r\n\r\n  if (options.overrideRootElement !== undefined) {\r\n    this.options.overrideRootElement = options.overrideRootElement;\r\n  }\r\n};\r\n\r\nWSDL.prototype.onReady = function(callback) {\r\n  if (callback)\r\n    this.callback = callback;\r\n};\r\n\r\nWSDL.prototype._processNextInclude = function(includes, callback) {\r\n  var self = this,\r\n    include = includes.shift(),\r\n    options;\r\n\r\n  if (!include)\r\n    return callback();\r\n\r\n  var includePath;\r\n  if (!/^https?:/.test(self.uri) && !/^https?:/.test(include.location)) {\r\n    includePath = path.resolve(path.dirname(self.uri), include.location);\r\n  } else {\r\n    includePath = url.resolve(self.uri||'', include.location);\r\n  }\r\n\r\n  options = _.assign({}, this.options);\r\n  // follow supplied ignoredNamespaces option\r\n  options.ignoredNamespaces = this._originalIgnoredNamespaces || this.options.ignoredNamespaces;\r\n  options.WSDL_CACHE = this.WSDL_CACHE;\r\n\r\n  open_wsdl_recursive(includePath, options, function(err, wsdl) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    self._includesWsdl.push(wsdl);\r\n\r\n    if (wsdl.definitions instanceof DefinitionsElement) {\r\n      _.merge(self.definitions, wsdl.definitions, function(a,b) {\r\n        return (a instanceof SchemaElement) ? a.merge(b) : undefined;\r\n      });\r\n    } else {\r\n      self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace] = deepMerge(self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace], wsdl.definitions);\r\n    }\r\n    self._processNextInclude(includes, function(err) {\r\n      callback(err);\r\n    });\r\n  });\r\n};\r\n\r\nWSDL.prototype.processIncludes = function(callback) {\r\n  var schemas = this.definitions.schemas,\r\n    includes = [];\r\n\r\n  for (var ns in schemas) {\r\n    var schema = schemas[ns];\r\n    includes = includes.concat(schema.includes || []);\r\n  }\r\n\r\n  this._processNextInclude(includes, callback);\r\n};\r\n\r\nWSDL.prototype.describeServices = function() {\r\n  var services = {};\r\n  for (var name in this.services) {\r\n    var service = this.services[name];\r\n    services[name] = service.description(this.definitions);\r\n  }\r\n  return services;\r\n};\r\n\r\nWSDL.prototype.toXML = function() {\r\n  return this.xml || '';\r\n};\r\n\r\nWSDL.prototype.xmlToObject = function(xml, callback) {\r\n  var self = this;\r\n  var p = typeof callback === 'function' ? {} : sax.parser(true);\r\n  var objectName = null;\r\n  var root = {};\r\n  var schema = {\r\n    Envelope: {\r\n      Header: {\r\n        Security: {\r\n          UsernameToken: {\r\n            Username: 'string',\r\n            Password: 'string'\r\n          }\r\n        }\r\n      },\r\n      Body: {\r\n        Fault: {\r\n          faultcode: 'string',\r\n          faultstring: 'string',\r\n          detail: 'string'\r\n        }\r\n      }\r\n    }\r\n  };\r\n  var stack = [{name: null, object: root, schema: schema}];\r\n  var xmlns = {};\r\n\r\n  var refs = {}, id; // {id:{hrefs:[],obj:}, ...}\r\n\r\n  p.onopentag = function(node) {\r\n    var nsName = node.name;\r\n    var attrs  = node.attributes;\r\n\r\n    var name = splitQName(nsName).name,\r\n      attributeName,\r\n      top = stack[stack.length - 1],\r\n      topSchema = top.schema,\r\n      elementAttributes = {},\r\n      hasNonXmlnsAttribute = false,\r\n      hasNilAttribute = false,\r\n      obj = {};\r\n    var originalName = name;\r\n\r\n    if (!objectName && top.name === 'Body' && name !== 'Fault') {\r\n      var message = self.definitions.messages[name];\r\n      // Support RPC/literal messages where response body contains one element named\r\n      // after the operation + 'Response'. See http://www.w3.org/TR/wsdl#_names\r\n      if (!message) {\r\n        // Determine if this is request or response\r\n        var isInput = false;\r\n        var isOutput = false;\r\n        if ((/Response$/).test(name)) {\r\n          isOutput = true;\r\n          name = name.replace(/Response$/, '');\r\n        } else if ((/Request$/).test(name)) {\r\n          isInput = true;\r\n          name = name.replace(/Request$/, '');\r\n        } else if ((/Solicit$/).test(name)) {\r\n          isInput = true;\r\n          name = name.replace(/Solicit$/, '');\r\n        }\r\n        // Look up the appropriate message as given in the portType's operations\r\n        var portTypes = self.definitions.portTypes;\r\n        var portTypeNames = Object.keys(portTypes);\r\n        // Currently this supports only one portType definition.\r\n        var portType = portTypes[portTypeNames[0]];\r\n        if (isInput) {\r\n          name = portType.methods[name].input.$name;\r\n        } else {\r\n          name = portType.methods[name].output.$name;\r\n        }\r\n        message = self.definitions.messages[name];\r\n        // 'cache' this alias to speed future lookups\r\n        self.definitions.messages[originalName] = self.definitions.messages[name];\r\n      }\r\n\r\n      topSchema = message.description(self.definitions);\r\n      objectName = originalName;\r\n    }\r\n\r\n    if (attrs.href) {\r\n      id = attrs.href.substr(1);\r\n      if (!refs[id]) {\r\n        refs[id] = {hrefs: [], obj: null};\r\n      }\r\n      refs[id].hrefs.push({par: top.object, key: name, obj: obj});\r\n    }\r\n    if (id = attrs.id) {\r\n      if (!refs[id]) {\r\n        refs[id] = {hrefs: [], obj: null};\r\n      }\r\n    }\r\n\r\n    //Handle element attributes\r\n    for (attributeName in attrs) {\r\n      if (/^xmlns:|^xmlns$/.test(attributeName)) {\r\n        xmlns[splitQName(attributeName).name] = attrs[attributeName];\r\n        continue;\r\n      }\r\n      hasNonXmlnsAttribute = true;\r\n      elementAttributes[attributeName] = attrs[attributeName];\r\n    }\r\n\r\n    for(attributeName in elementAttributes){\r\n      var res = splitQName(attributeName);\r\n      if (res.name === 'nil' && xmlns[res.prefix] === 'http://www.w3.org/2001/XMLSchema-instance') {\r\n        hasNilAttribute = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (hasNonXmlnsAttribute) {\r\n      obj[self.options.attributesKey] = elementAttributes;\r\n    }\r\n\r\n    // Pick up the schema for the type specified in element's xsi:type attribute.\r\n    var xsiTypeSchema;\r\n    var xsiType = elementAttributes['xsi:type'];\r\n    if (xsiType) {\r\n      var type = splitQName(xsiType);\r\n      var typeURI;\r\n      if (type.prefix === TNS_PREFIX) {\r\n        // In case of xsi:type = \"MyType\"\r\n        typeURI = xmlns[type.prefix] || xmlns.xmlns;\r\n      } else {\r\n        typeURI = xmlns[type.prefix];\r\n      }\r\n      var typeDef = self.findSchemaObject(typeURI, type.name);\r\n      if (typeDef) {\r\n        xsiTypeSchema = typeDef.description(self.definitions);\r\n      }\r\n    }\r\n\r\n    if (topSchema && topSchema[name + '[]']) {\r\n      name = name + '[]';\r\n    }\r\n    stack.push({name: originalName, object: obj, schema: (xsiTypeSchema || (topSchema && topSchema[name])), id: attrs.id, nil: hasNilAttribute});\r\n  };\r\n\r\n  p.onclosetag = function(nsName) {\r\n    var cur = stack.pop(),\r\n      obj = cur.object,\r\n      top = stack[stack.length - 1],\r\n      topObject = top.object,\r\n      topSchema = top.schema,\r\n      name = splitQName(nsName).name;\r\n\r\n    if (typeof cur.schema === 'string' && (cur.schema === 'string' || cur.schema.split(':')[1] === 'string')) {\r\n      if (typeof obj === 'object' &&  Object.keys(obj).length === 0) obj = cur.object = '';\r\n    }\r\n\r\n    if (cur.nil === true) {\r\n      return;\r\n    }\r\n\r\n    if (_.isPlainObject(obj) && !Object.keys(obj).length) {\r\n      obj = null;\r\n    }\r\n\r\n    if (topSchema && topSchema[name + '[]']) {\r\n      if (!topObject[name]) {\r\n        topObject[name] = [];\r\n      }\r\n      topObject[name].push(obj);\r\n    } else if (name in topObject) {\r\n      if (!Array.isArray(topObject[name])) {\r\n        topObject[name] = [topObject[name]];\r\n      }\r\n      topObject[name].push(obj);\r\n    } else {\r\n      topObject[name] = obj;\r\n    }\r\n\r\n    if (cur.id) {\r\n      refs[cur.id].obj = obj;\r\n    }\r\n  };\r\n\r\n  p.oncdata = function (text) {\r\n    text = trim(text);\r\n    if (!text.length) {\r\n      return;\r\n    }\r\n\r\n    if (/<\\?xml[\\s\\S]+\\?>/.test(text)) {\r\n      var top = stack[stack.length - 1];\r\n      var value = self.xmlToObject(text);\r\n      if (top.object[self.options.attributesKey]) {\r\n        top.object[self.options.valueKey] = value;\r\n      } else {\r\n        top.object = value;\r\n      }\r\n    } else {\r\n      p.ontext(text);\r\n    }\r\n  };\r\n\r\n  p.onerror = function(e) {\r\n    p.resume();\r\n    throw {\r\n      Fault: {\r\n        faultcode: 500,\r\n        faultstring: 'Invalid XML',\r\n        detail: new Error(e).message,\r\n        statusCode: 500\r\n      }\r\n    };\r\n  };\r\n\r\n  p.ontext = function(text) {\r\n    text = trim(text);\r\n    if (!text.length) {\r\n      return;\r\n    }\r\n\r\n    var top = stack[stack.length - 1];\r\n    var name = splitQName(top.schema).name,\r\n      value;\r\n    if (self.options && self.options.customDeserializer && self.options.customDeserializer[name]) {\r\n      value = self.options.customDeserializer[name](text, top);\r\n    }\r\n    else {\r\n      if (name === 'int' || name === 'integer') {\r\n        value = parseInt(text, 10);\r\n      } else if (name === 'bool' || name === 'boolean') {\r\n        value = text.toLowerCase() === 'true' || text === '1';\r\n      } else if (name === 'dateTime' || name === 'date') {\r\n        value = new Date(text);\r\n      } else {\r\n        // handle string or other types\r\n        if (typeof top.object !== 'string') {\r\n          value = text;\r\n        } else {\r\n          value = top.object + text;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (top.object[self.options.attributesKey]) {\r\n      top.object[self.options.valueKey] = value;\r\n    } else {\r\n      top.object = value;\r\n    }\r\n  };\r\n\r\n  if (typeof callback === 'function') {\r\n    // we be streaming\r\n    var saxStream = sax.createStream(true);\r\n    saxStream.on('opentag', p.onopentag);\r\n    saxStream.on('closetag', p.onclosetag);\r\n    saxStream.on('cdata', p.oncdata);\r\n    saxStream.on('text', p.ontext);\r\n    xml.pipe(saxStream)\r\n    .on('error', function (err) {\r\n      callback(err);\r\n    })\r\n    .on('end', function () {\r\n      var r;\r\n      try {\r\n        r = finish();\r\n      } catch (e) {\r\n        return callback(e);\r\n      }\r\n      callback(null, r);\r\n    });\r\n    return;\r\n  }\r\n  p.write(xml).close();\r\n\r\n  return finish();\r\n\r\n  function finish() {\r\n    // MultiRef support: merge objects instead of replacing\r\n    for (var n in refs) {\r\n      var ref = refs[n];\r\n      for (var i = 0; i < ref.hrefs.length; i++) {\r\n        _.assign(ref.hrefs[i].obj, ref.obj);\r\n      }\r\n    }\r\n\r\n    if (root.Envelope) {\r\n      var body = root.Envelope.Body;\r\n      if (body && body.Fault) {\r\n        var code = selectn('faultcode.$value', body.Fault) || selectn('faultcode', body.Fault);\r\n        var string = selectn('faultstring.$value', body.Fault) || selectn('faultstring', body.Fault);\r\n        var detail = selectn('detail.$value', body.Fault) || selectn('detail.message', body.Fault);\r\n        var error = new Error(code + ': ' + string + (detail ? ': ' + detail : ''));\r\n        error.root = root;\r\n        throw error;\r\n      }\r\n      return root.Envelope;\r\n    }\r\n    return root;\r\n  }\r\n};\r\n\r\n/**\r\n * Look up a XSD type or element by namespace URI and name\r\n * @param {String} nsURI Namespace URI\r\n * @param {String} qname Local or qualified name\r\n * @returns {*} The XSD type/element definition\r\n */\r\nWSDL.prototype.findSchemaObject = function(nsURI, qname) {\r\n  if (!nsURI || !qname) {\r\n    return null;\r\n  }\r\n\r\n  var def = null;\r\n\r\n  if (this.definitions.schemas) {\r\n    var schema = this.definitions.schemas[nsURI];\r\n    if (schema) {\r\n      if (qname.indexOf(':') !== -1) {\r\n        qname = qname.substring(qname.indexOf(':') + 1, qname.length);\r\n      }\r\n\r\n      // if the client passed an input element which has a `$lookupType` property instead of `$type`\r\n      // the `def` is found in `schema.elements`.\r\n      def = schema.complexTypes[qname] || schema.types[qname] || schema.elements[qname];\r\n    }\r\n  }\r\n\r\n  return def;\r\n};\r\n\r\n/**\r\n * Create document style xml string from the parameters\r\n * @param {String} name\r\n * @param {*} params\r\n * @param {String} nsPrefix\r\n * @param {String} nsURI\r\n * @param {String} type\r\n */\r\nWSDL.prototype.objectToDocumentXML = function(name, params, nsPrefix, nsURI, type) {\r\n  var args = {};\r\n  args[name] = params;\r\n  var parameterTypeObj = type ? this.findSchemaObject(nsURI, type) : null;\r\n  return this.objectToXML(args, null, nsPrefix, nsURI, true, null, parameterTypeObj);\r\n};\r\n\r\n/**\r\n * Create RPC style xml string from the parameters\r\n * @param {String} name\r\n * @param {*} params\r\n * @param {String} nsPrefix\r\n * @param {String} nsURI\r\n * @returns {string}\r\n */\r\nWSDL.prototype.objectToRpcXML = function(name, params, nsPrefix, nsURI,isParts) {\r\n  var parts = [];\r\n  var defs = this.definitions;\r\n  var nsAttrName = '_xmlns';\r\n\r\n  nsPrefix = nsPrefix || findPrefix(defs.xmlns, nsURI);\r\n\r\n  nsURI = nsURI || defs.xmlns[nsPrefix];\r\n  nsPrefix = nsPrefix === TNS_PREFIX ? '' : (nsPrefix + ':');\r\n\r\n  parts.push(['<', nsPrefix, name, '>'].join(''));\r\n\r\n  for (var key in params) {\r\n    if (!params.hasOwnProperty(key)) {\r\n      continue;\r\n    }\r\n    if (key !== nsAttrName) {\r\n      var value = params[key];\r\n      var prefixedKey = (isParts ? '' : nsPrefix) + key;\r\n      parts.push(['<', prefixedKey, '>'].join(''));\r\n      parts.push((typeof value === 'object') ? this.objectToXML(value, key, nsPrefix, nsURI) : xmlEscape(value));\r\n      parts.push(['</', prefixedKey, '>'].join(''));\r\n    }\r\n  }\r\n  parts.push(['</', nsPrefix, name, '>'].join(''));\r\n  return parts.join('');\r\n};\r\n\r\n\r\nfunction appendColon(ns) {\r\n  return (ns && ns.charAt(ns.length - 1) !== ':') ? ns + ':' : ns;\r\n}\r\n\r\nfunction noColonNameSpace(ns) {\r\n  return (ns && ns.charAt(ns.length - 1) === ':') ? ns.substring(0, ns.length - 1) : ns;\r\n}\r\n\r\nWSDL.prototype.isIgnoredNameSpace = function(ns) {\r\n  return this.options.ignoredNamespaces.indexOf(ns) > -1;\r\n};\r\n\r\nWSDL.prototype.filterOutIgnoredNameSpace = function(ns) {\r\n  var namespace = noColonNameSpace(ns);\r\n  return this.isIgnoredNameSpace(namespace) ? '' : namespace;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Convert an object to XML.  This is a recursive method as it calls itself.\r\n *\r\n * @param {Object} obj the object to convert.\r\n * @param {String} name the name of the element (if the object being traversed is\r\n * an element).\r\n * @param {String} nsPrefix the namespace prefix of the object I.E. xsd.\r\n * @param {String} nsURI the full namespace of the object I.E. http://w3.org/schema.\r\n * @param {Boolean} isFirst whether or not this is the first item being traversed.\r\n * @param {?} xmlnsAttr\r\n * @param {?} parameterTypeObject\r\n * @param {NamespaceContext} nsContext Namespace context\r\n */\r\nWSDL.prototype.objectToXML = function(obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext) {\r\n  var self = this;\r\n  var schema = this.definitions.schemas[nsURI];\r\n\r\n  var parentNsPrefix = nsPrefix ? nsPrefix.parent : undefined;\r\n  if (typeof parentNsPrefix !== 'undefined') {\r\n    //we got the parentNsPrefix for our array. setting the namespace-variable back to the current namespace string\r\n    nsPrefix = nsPrefix.current;\r\n  }\r\n\r\n  parentNsPrefix = noColonNameSpace(parentNsPrefix);\r\n  if (this.isIgnoredNameSpace(parentNsPrefix)) {\r\n    parentNsPrefix = '';\r\n  }\r\n\r\n  var soapHeader = !schema;\r\n  var qualified = schema && schema.$elementFormDefault === 'qualified';\r\n  var parts = [];\r\n  var prefixNamespace = (nsPrefix || qualified) && nsPrefix !== TNS_PREFIX;\r\n\r\n  var xmlnsAttrib = '';\r\n  if (nsURI && isFirst) {\r\n    if(self.options.overrideRootElement && self.options.overrideRootElement.xmlnsAttributes) {\r\n      self.options.overrideRootElement.xmlnsAttributes.forEach(function(attribute) {\r\n        xmlnsAttrib += ' ' + attribute.name + '=\"' + attribute.value + '\"';\r\n      });\r\n    } else {\r\n      if (prefixNamespace && !this.isIgnoredNameSpace(nsPrefix)) {\r\n        // resolve the prefix namespace\r\n        xmlnsAttrib += ' xmlns:' + nsPrefix + '=\"' + nsURI + '\"';\r\n      }\r\n      // only add default namespace if the schema elementFormDefault is qualified\r\n      if (qualified || soapHeader) xmlnsAttrib += ' xmlns=\"' + nsURI + '\"';\r\n    }\r\n  }\r\n\r\n  if (!nsContext) {\r\n    nsContext = new NamespaceContext();\r\n    nsContext.declareNamespace(nsPrefix, nsURI);\r\n  } else {\r\n    nsContext.pushContext();\r\n  }\r\n\r\n  // explicitly use xmlns attribute if available\r\n  if (xmlnsAttr && !(self.options.overrideRootElement && self.options.overrideRootElement.xmlnsAttributes)) {\r\n    xmlnsAttrib = xmlnsAttr;\r\n  }\r\n\r\n  var ns = '';\r\n\r\n  if (self.options.overrideRootElement && isFirst) {\r\n    ns = self.options.overrideRootElement.namespace;\r\n  } else if (prefixNamespace && (qualified || isFirst || soapHeader) && !this.isIgnoredNameSpace(nsPrefix)) {\r\n    ns = nsPrefix;\r\n  }\r\n\r\n  var i, n;\r\n  // start building out XML string.\r\n  if (Array.isArray(obj)) {\r\n    for (i = 0, n = obj.length; i < n; i++) {\r\n      var item = obj[i];\r\n      var arrayAttr = self.processAttributes(item, nsContext),\r\n          correctOuterNsPrefix = parentNsPrefix || ns; //using the parent namespace prefix if given\r\n\r\n      parts.push(['<', appendColon(correctOuterNsPrefix), name, arrayAttr, xmlnsAttrib, '>'].join(''));\r\n      parts.push(self.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext));\r\n      parts.push(['</', appendColon(correctOuterNsPrefix), name, '>'].join(''));\r\n    }\r\n  } else if (typeof obj === 'object') {\r\n    for (name in obj) {\r\n      if (!obj.hasOwnProperty(name)) continue;\r\n      //don't process attributes as element\r\n      if (name === self.options.attributesKey) {\r\n        continue;\r\n      }\r\n      //Its the value of a xml object. Return it directly.\r\n      if (name === self.options.xmlKey){\r\n        nsContext.popContext();\r\n        return obj[name];\r\n      }\r\n      //Its the value of an item. Return it directly.\r\n      if (name === self.options.valueKey) {\r\n        nsContext.popContext();\r\n        return xmlEscape(obj[name]);\r\n      }\r\n\r\n      var child = obj[name];\r\n      if (typeof child === 'undefined') {\r\n        continue;\r\n      }\r\n\r\n      var attr = self.processAttributes(child, nsContext);\r\n\r\n      var value = '';\r\n      var nonSubNameSpace = '';\r\n      var emptyNonSubNameSpace = false;\r\n\r\n      var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);\r\n      if (nameWithNsRegex) {\r\n        nonSubNameSpace = nameWithNsRegex[1] + ':';\r\n        name = nameWithNsRegex[2];\r\n      } else if(name[0] === ':'){\r\n        emptyNonSubNameSpace = true;\r\n        name = name.substr(1);\r\n      }\r\n\r\n      if (isFirst) {\r\n        value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);\r\n      } else {\r\n\r\n        if (self.definitions.schemas) {\r\n          if (schema) {\r\n            var childSchemaObject = self.findChildSchemaObject(schemaObject, name);\r\n            //find sub namespace if not a primitive\r\n            if (childSchemaObject &&\r\n              ((childSchemaObject.$type && (childSchemaObject.$type.indexOf('xsd:') === -1)) ||\r\n              childSchemaObject.$ref || childSchemaObject.$name)) {\r\n              /*if the base name space of the children is not in the ingoredSchemaNamspaces we use it.\r\n               This is because in some services the child nodes do not need the baseNameSpace.\r\n               */\r\n\r\n              var childNsPrefix = '';\r\n              var childName = '';\r\n              var childNsURI;\r\n              var childXmlnsAttrib = '';\r\n\r\n              var elementQName = childSchemaObject.$ref || childSchemaObject.$name;\r\n              if (elementQName) {\r\n                elementQName = splitQName(elementQName);\r\n                childName = elementQName.name;\r\n                if (elementQName.prefix === TNS_PREFIX) {\r\n                  // Local element\r\n                  childNsURI = childSchemaObject.$targetNamespace;\r\n                  childNsPrefix = nsContext.registerNamespace(childNsURI);\r\n                  if (this.isIgnoredNameSpace(childNsPrefix)) {\r\n                    childNsPrefix = nsPrefix;\r\n                  }\r\n                } else {\r\n                  childNsPrefix = elementQName.prefix;\r\n                  if (this.isIgnoredNameSpace(childNsPrefix)) {\r\n                    childNsPrefix = nsPrefix;\r\n                  }\r\n                  childNsURI = schema.xmlns[childNsPrefix] || self.definitions.xmlns[childNsPrefix];\r\n                }\r\n\r\n                var unqualified = false;\r\n                // Check qualification form for local elements\r\n                if (childSchemaObject.$name && childSchemaObject.targetNamespace === undefined) {\r\n                  if (childSchemaObject.$form === 'unqualified') {\r\n                    unqualified = true;\r\n                  } else if (childSchemaObject.$form === 'qualified') {\r\n                    unqualified = false;\r\n                  } else {\r\n                    unqualified = schema.$elementFormDefault !== 'qualified';\r\n                  }\r\n                }\r\n                if (unqualified) {\r\n                  childNsPrefix = '';\r\n                }\r\n\r\n                if (childNsURI && childNsPrefix) {\r\n                  if (nsContext.declareNamespace(childNsPrefix, childNsURI)) {\r\n                    childXmlnsAttrib = ' xmlns:' + childNsPrefix + '=\"' + childNsURI + '\"';\r\n                    xmlnsAttrib += childXmlnsAttrib;\r\n                  }\r\n                }\r\n              }\r\n\r\n              var resolvedChildSchemaObject;\r\n              if (childSchemaObject.$type) {\r\n                var typeQName = splitQName(childSchemaObject.$type);\r\n                var typePrefix = typeQName.prefix;\r\n                var typeURI = schema.xmlns[typePrefix] || self.definitions.xmlns[typePrefix];\r\n                childNsURI = typeURI;\r\n                if (typeURI !== 'http://www.w3.org/2001/XMLSchema' && typePrefix !== TNS_PREFIX) {\r\n                  // Add the prefix/namespace mapping, but not declare it\r\n                  nsContext.addNamespace(typePrefix, typeURI);\r\n                }\r\n                resolvedChildSchemaObject =\r\n                  self.findSchemaType(typeQName.name, typeURI) || childSchemaObject;\r\n              } else {\r\n                resolvedChildSchemaObject =\r\n                  self.findSchemaObject(childNsURI, childName) || childSchemaObject;\r\n              }\r\n\r\n              if (childSchemaObject.$baseNameSpace && this.options.ignoreBaseNameSpaces) {\r\n                childNsPrefix = nsPrefix;\r\n                childNsURI = nsURI;\r\n              }\r\n\r\n              if (this.options.ignoreBaseNameSpaces) {\r\n                childNsPrefix = '';\r\n                childNsURI = '';\r\n              }\r\n\r\n              ns = childNsPrefix;\r\n\r\n              if (Array.isArray(child)) {\r\n                //for arrays, we need to remember the current namespace\r\n                childNsPrefix = {\r\n                  current: childNsPrefix,\r\n                  parent: ns\r\n                };\r\n              } else {\r\n                //parent (array) already got the namespace\r\n                childXmlnsAttrib = null;\r\n              }\r\n\r\n              value = self.objectToXML(child, name, childNsPrefix, childNsURI,\r\n                false, childXmlnsAttrib, resolvedChildSchemaObject, nsContext);\r\n            } else if (obj[self.options.attributesKey] && obj[self.options.attributesKey].xsi_type) {\r\n              //if parent object has complex type defined and child not found in parent\r\n              var completeChildParamTypeObject = self.findChildSchemaObject(\r\n                obj[self.options.attributesKey].xsi_type.type,\r\n                obj[self.options.attributesKey].xsi_type.xmlns);\r\n\r\n              nonSubNameSpace = obj[self.options.attributesKey].xsi_type.prefix;\r\n              nsContext.addNamespace(obj[self.options.attributesKey].xsi_type.prefix,\r\n                obj[self.options.attributesKey].xsi_type.xmlns);\r\n              value = self.objectToXML(child, name, obj[self.options.attributesKey].xsi_type.prefix,\r\n                obj[self.options.attributesKey].xsi_type.xmlns, false, null, null, nsContext);\r\n            } else {\r\n              if(Array.isArray(child)) {\r\n                name = nonSubNameSpace + name;\r\n              }\r\n\r\n              value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\r\n            }\r\n          } else {\r\n            value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);\r\n          }\r\n        }\r\n      }\r\n\r\n      ns = noColonNameSpace(ns);\r\n      if (prefixNamespace && !qualified && isFirst && !self.options.overrideRootElement) {\r\n        ns = nsPrefix;\r\n      } else if (this.isIgnoredNameSpace(ns)) {\r\n        ns = '';\r\n      }\r\n\r\n      if (!Array.isArray(child)) {\r\n        // start tag\r\n        parts.push(['<', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, attr, xmlnsAttrib,\r\n          (child === null ? ' xsi:nil=\"true\"' : ''), '>'].join(''));\r\n      }\r\n      parts.push(value);\r\n      if (!Array.isArray(child)) {\r\n        // end tag\r\n        parts.push(['</', emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns), name, '>'].join(''));\r\n      }\r\n    }\r\n  } else if (obj !== undefined) {\r\n    parts.push((self.options.escapeXML) ? xmlEscape(obj) : obj);\r\n  }\r\n  nsContext.popContext();\r\n  return parts.join('');\r\n};\r\n\r\nWSDL.prototype.processAttributes = function(child, nsContext) {\r\n  var attr = '';\r\n\r\n  if(child === null) {\r\n    child = [];\r\n  }\r\n\r\n  var attrObj = child[this.options.attributesKey];\r\n  if (attrObj && attrObj.xsi_type) {\r\n    var xsiType = attrObj.xsi_type;\r\n\r\n    var prefix = xsiType.prefix || xsiType.namespace;\r\n    // Generate a new namespace for complex extension if one not provided\r\n    if (!prefix) {\r\n      prefix = nsContext.registerNamespace(xsiType.xmlns);\r\n    } else {\r\n      nsContext.declareNamespace(prefix, xsiType.xmlns);\r\n    }\r\n    xsiType.prefix = prefix;\r\n  }\r\n\r\n\r\n  if (attrObj) {\r\n    for (var attrKey in attrObj) {\r\n      //handle complex extension separately\r\n      if (attrKey === 'xsi_type') {\r\n        var attrValue = attrObj[attrKey];\r\n        attr += ' xsi:type=\"' + attrValue.prefix + ':' + attrValue.type + '\"';\r\n        attr += ' xmlns:' + attrValue.prefix + '=\"' + attrValue.xmlns + '\"';\r\n\r\n        continue;\r\n      } else {\r\n        attr += ' ' + attrKey + '=\"' + xmlEscape(attrObj[attrKey]) + '\"';\r\n      }\r\n    }\r\n  }\r\n\r\n  return attr;\r\n};\r\n\r\n/**\r\n * Look up a schema type definition\r\n * @param name\r\n * @param nsURI\r\n * @returns {*}\r\n */\r\nWSDL.prototype.findSchemaType = function(name, nsURI) {\r\n  if (!this.definitions.schemas || !name || !nsURI) {\r\n    return null;\r\n  }\r\n\r\n  var schema = this.definitions.schemas[nsURI];\r\n  if (!schema || !schema.complexTypes) {\r\n    return null;\r\n  }\r\n\r\n  return schema.complexTypes[name];\r\n};\r\n\r\nWSDL.prototype.findChildSchemaObject = function(parameterTypeObj, childName) {\r\n  if (!parameterTypeObj || !childName) {\r\n    return null;\r\n  }\r\n  var found = null,\r\n      i = 0,\r\n      child,\r\n      ref;\r\n\r\n  if (Array.isArray(parameterTypeObj.$lookupTypes) && parameterTypeObj.$lookupTypes.length) {\r\n    var types = parameterTypeObj.$lookupTypes;\r\n\r\n    for(i = 0; i < types.length; i++) {\r\n      var typeObj = types[i];\r\n\r\n      if(typeObj.$name === childName) {\r\n        found = typeObj;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  var object = parameterTypeObj;\r\n  if (object.$name === childName && object.name === 'element') {\r\n    return object;\r\n  }\r\n  if (object.$ref) {\r\n    ref = splitQName(object.$ref);\r\n    if (ref.name === childName) {\r\n      return object;\r\n    }\r\n  }\r\n\r\n  var childNsURI;\r\n  if (object.$type) {\r\n    var typeInfo = splitQName(object.$type);\r\n    if (typeInfo.prefix === TNS_PREFIX) {\r\n      childNsURI = parameterTypeObj.$targetNamespace;\r\n    } else {\r\n      childNsURI = this.definitions.xmlns[typeInfo.prefix];\r\n    }\r\n    var typeDef = this.findSchemaType(typeInfo.name, childNsURI);\r\n    if (typeDef) {\r\n      return this.findChildSchemaObject(typeDef, childName);\r\n    }\r\n  }\r\n\r\n  if (object.children) {\r\n    for (i = 0, child; child = object.children[i]; i++) {\r\n      found = this.findChildSchemaObject(child, childName);\r\n      if (found) {\r\n        break;\r\n      }\r\n\r\n      if (child.$base) {\r\n        var baseQName = splitQName(child.$base);\r\n        var childNameSpace = baseQName.prefix === TNS_PREFIX ? '' : baseQName.prefix;\r\n        childNsURI = this.definitions.xmlns[baseQName.prefix];\r\n\r\n        var foundBase = this.findSchemaType(baseQName.name, childNsURI);\r\n\r\n        if (foundBase) {\r\n          found = this.findChildSchemaObject(foundBase, childName);\r\n\r\n          if (found) {\r\n            found.$baseNameSpace = childNameSpace;\r\n            found.$type = childNameSpace + ':' + childName;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  if (!found && object.$name === childName) {\r\n    return object;\r\n  }\r\n\r\n  return found;\r\n};\r\n\r\nWSDL.prototype._parse = function(xml) {\r\n  var self = this,\r\n    p = sax.parser(true),\r\n    stack = [],\r\n    root = null,\r\n    types = null,\r\n    schema = null,\r\n      options = self.options;\r\n\r\n  p.onopentag = function(node) {\r\n    var nsName = node.name;\r\n    var attrs  = node.attributes;\r\n\r\n    var top = stack[stack.length - 1];\r\n    var name;\r\n    if (top) {\r\n      try {\r\n        top.startElement(stack, nsName, attrs, options);\r\n      } catch (e) {\r\n        if (self.options.strict) {\r\n          throw e;\r\n        } else {\r\n          stack.push(new Element(nsName, attrs, options));\r\n        }\r\n      }\r\n    } else {\r\n      name = splitQName(nsName).name;\r\n      if (name === 'definitions') {\r\n        root = new DefinitionsElement(nsName, attrs, options);\r\n        stack.push(root);\r\n      } else if (name === 'schema') {\r\n        // Shim a structure in here to allow the proper objects to be created when merging back.\r\n        root = new DefinitionsElement('definitions', {}, {});\r\n        types = new TypesElement('types', {}, {});\r\n        schema = new SchemaElement(nsName, attrs, options);\r\n        types.addChild(schema);\r\n        root.addChild(types);\r\n        stack.push(schema);\r\n      } else {\r\n        throw new Error('Unexpected root element of WSDL or include');\r\n      }\r\n    }\r\n  };\r\n\r\n  p.onclosetag = function(name) {\r\n    var top = stack[stack.length - 1];\r\n    assert(top, 'Unmatched close tag: ' + name);\r\n\r\n    top.endElement(stack, name);\r\n  };\r\n\r\n  p.write(xml).close();\r\n\r\n  return root;\r\n};\r\n\r\nWSDL.prototype._fromXML = function(xml) {\r\n  this.definitions = this._parse(xml);\r\n  this.definitions.descriptions = {\r\n    types:{}\r\n  };\r\n  this.xml = xml;\r\n};\r\n\r\nWSDL.prototype._fromServices = function(services) {\r\n\r\n};\r\n\r\nWSDL.prototype._splitQName = splitQName;\r\n\r\nWSDL.prototype._xmlnsMap = function() {\r\n  var xmlns = this.definitions.xmlns;\r\n  var str = '';\r\n  for (var alias in xmlns) {\r\n    if (alias === '' || alias === TNS_PREFIX) {\r\n      continue;\r\n    }\r\n    var ns = xmlns[alias];\r\n    switch (ns) {\r\n      case \"http://xml.apache.org/xml-soap\" : // apachesoap\r\n      case \"http://schemas.xmlsoap.org/wsdl/\" : // wsdl\r\n      case \"http://schemas.xmlsoap.org/wsdl/soap/\" : // wsdlsoap\r\n      case \"http://schemas.xmlsoap.org/wsdl/soap12/\": // wsdlsoap12\r\n      case \"http://schemas.xmlsoap.org/soap/encoding/\" : // soapenc\r\n      case \"http://www.w3.org/2001/XMLSchema\" : // xsd\r\n        continue;\r\n    }\r\n    if (~ns.indexOf('http://schemas.xmlsoap.org/')) {\r\n      continue;\r\n    }\r\n    if (~ns.indexOf('http://www.w3.org/')) {\r\n      continue;\r\n    }\r\n    if (~ns.indexOf('http://xml.apache.org/')) {\r\n      continue;\r\n    }\r\n    str += ' xmlns:' + alias + '=\"' + ns + '\"';\r\n  }\r\n  return str;\r\n};\r\n\r\n/*\r\n * Have another function to load previous WSDLs as we\r\n * don't want this to be invoked externally (expect for tests)\r\n * This will attempt to fix circular dependencies with XSD files,\r\n * Given\r\n * - file.wsdl\r\n *   - xs:import namespace=\"A\" schemaLocation: A.xsd\r\n * - A.xsd\r\n *   - xs:import namespace=\"B\" schemaLocation: B.xsd\r\n * - B.xsd\r\n *   - xs:import namespace=\"A\" schemaLocation: A.xsd\r\n * file.wsdl will start loading, import A, then A will import B, which will then import A\r\n * Because A has already started to load previously it will be returned right away and\r\n * have an internal circular reference\r\n * B would then complete loading, then A, then file.wsdl\r\n * By the time file A starts processing its includes its definitions will be already loaded,\r\n * this is the only thing that B will depend on when \"opening\" A\r\n */\r\nfunction open_wsdl_recursive(uri, options, callback) {\r\n  var fromCache,\r\n      WSDL_CACHE;\r\n\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  WSDL_CACHE = options.WSDL_CACHE;\r\n\r\n  if (fromCache = WSDL_CACHE[ uri ]) {\r\n    return callback.call(fromCache, null, fromCache);\r\n  }\r\n\r\n  return open_wsdl(uri, options, callback);\r\n}\r\n\r\nfunction open_wsdl(uri, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  // initialize cache when calling open_wsdl directly\r\n  var WSDL_CACHE = options.WSDL_CACHE || {};\r\n  var request_headers = options.wsdl_headers;\r\n  var request_options = options.wsdl_options;\r\n\r\n  var wsdl;\r\n  if (!/^https?:/.test(uri)) {\r\n    debug('Reading file: %s', uri);\r\n    fs.readFile(uri, 'utf8', function(err, definition) {\r\n      if (err) {\r\n        callback(err);\r\n      }\r\n      else {\r\n        wsdl = new WSDL(definition, uri, options);\r\n        WSDL_CACHE[ uri ] = wsdl;\r\n        wsdl.WSDL_CACHE = WSDL_CACHE;\r\n        wsdl.onReady(callback);\r\n      }\r\n    });\r\n  }\r\n  else {\r\n    debug('Reading url: %s', uri);\r\n    var httpClient = options.httpClient || new HttpClient(options);\r\n    httpClient.request(uri, null /* options */, function(err, response, definition) {\r\n      if (err) {\r\n        callback(err);\r\n      } else if (response && response.statusCode === 200) {\r\n        wsdl = new WSDL(definition, uri, options);\r\n        WSDL_CACHE[ uri ] = wsdl;\r\n        wsdl.WSDL_CACHE = WSDL_CACHE;\r\n        wsdl.onReady(callback);\r\n      } else {\r\n        callback(new Error('Invalid WSDL URL: ' + uri + \"\\n\\n\\r Code: \" + response.statusCode + \"\\n\\n\\r Response Body: \" + response.body));\r\n      }\r\n    }, request_headers, request_options);\r\n  }\r\n\r\n  return wsdl;\r\n}\r\n\r\nexports.open_wsdl = open_wsdl;\r\nexports.WSDL = WSDL;\r\n","/home/travis/build/npmtest/node-npmtest-soap/soap/lib/nscontext.js":"'use strict';\r\n\r\nmodule.exports = NamespaceContext;\r\n\r\n/**\r\n * Scope for XML namespaces\r\n * @param {NamespaceScope} [parent] Parent scope\r\n * @returns {NamespaceScope}\r\n * @constructor\r\n */\r\nfunction NamespaceScope(parent) {\r\n  if (!(this instanceof NamespaceScope)) {\r\n    return new NamespaceScope(parent);\r\n  }\r\n  this.parent = parent;\r\n  this.namespaces = {};\r\n}\r\n\r\n/**\r\n * Namespace context that manages hierarchical scopes\r\n * @returns {NamespaceContext}\r\n * @constructor\r\n */\r\nfunction NamespaceContext() {\r\n  if (!(this instanceof NamespaceContext)) {\r\n    return new NamespaceContext();\r\n  }\r\n  this.scopes = [];\r\n  this.pushContext();\r\n  this.prefixCount = 0;\r\n}\r\n\r\n/**\r\n * Look up the namespace URI by prefix\r\n * @param {String} prefix Namespace prefix\r\n * @param {Boolean} [localOnly] Search current scope only\r\n * @returns {String} Namespace URI\r\n */\r\nNamespaceScope.prototype.getNamespaceURI = function(prefix, localOnly) {\r\n  switch (prefix) {\r\n    case 'xml':\r\n      return 'http://www.w3.org/XML/1998/namespace';\r\n    case 'xmlns':\r\n      return 'http://www.w3.org/2000/xmlns/';\r\n    default:\r\n      var nsUri = this.namespaces[prefix];\r\n      /*jshint -W116 */\r\n      if (nsUri != null) {\r\n        return nsUri.uri;\r\n      } else if (!localOnly && this.parent) {\r\n        return this.parent.getNamespaceURI(prefix);\r\n      } else {\r\n        return null;\r\n      }\r\n  }\r\n};\r\n\r\nNamespaceScope.prototype.getNamespaceMapping = function(prefix) {\r\n  switch (prefix) {\r\n    case 'xml':\r\n      return {\r\n        uri: 'http://www.w3.org/XML/1998/namespace',\r\n        prefix: 'xml',\r\n        declared: true\r\n      };\r\n    case 'xmlns':\r\n      return {\r\n        uri: 'http://www.w3.org/2000/xmlns/',\r\n        prefix: 'xmlns',\r\n        declared: true\r\n      };\r\n    default:\r\n      var mapping = this.namespaces[prefix];\r\n      /*jshint -W116 */\r\n      if (mapping != null) {\r\n        return mapping;\r\n      } else if (this.parent) {\r\n        return this.parent.getNamespaceMapping(prefix);\r\n      } else {\r\n        return null;\r\n      }\r\n  }\r\n};\r\n\r\n/**\r\n * Look up the namespace prefix by URI\r\n * @param {String} nsUri Namespace URI\r\n * @param {Boolean} [localOnly] Search current scope only\r\n * @returns {String} Namespace prefix\r\n */\r\nNamespaceScope.prototype.getPrefix = function(nsUri, localOnly) {\r\n  switch (nsUri) {\r\n    case 'http://www.w3.org/XML/1998/namespace':\r\n      return 'xml';\r\n    case 'http://www.w3.org/2000/xmlns/':\r\n      return 'xmlns';\r\n    default:\r\n      for (var p in this.namespaces) {\r\n        if (this.namespaces[p].uri === nsUri) {\r\n          return p;\r\n        }\r\n      }\r\n      if (!localOnly && this.parent) {\r\n        return this.parent.getPrefix(nsUri);\r\n      } else {\r\n        return null;\r\n      }\r\n  }\r\n};\r\n\r\n/**\r\n * Add a prefix/URI namespace mapping\r\n * @param {String} prefix Namespace prefix\r\n * @param {String} nsUri Namespace URI\r\n * @param {Boolean} [localOnly] Search current scope only\r\n * @returns {boolean} true if the mapping is added or false if the mapping\r\n * already exists\r\n */\r\nNamespaceContext.prototype.addNamespace = function(prefix, nsUri, localOnly) {\r\n  if (this.getNamespaceURI(prefix, localOnly) === nsUri) {\r\n    return false;\r\n  }\r\n  if (this.currentScope) {\r\n    this.currentScope.namespaces[prefix] = {\r\n      uri: nsUri,\r\n      prefix: prefix,\r\n      declared: false\r\n    };\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Push a scope into the context\r\n * @returns {NamespaceScope} The current scope\r\n */\r\nNamespaceContext.prototype.pushContext = function() {\r\n  var scope = new NamespaceScope(this.currentScope);\r\n  this.scopes.push(scope);\r\n  this.currentScope = scope;\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Pop a scope out of the context\r\n * @returns {NamespaceScope} The removed scope\r\n */\r\nNamespaceContext.prototype.popContext = function() {\r\n  var scope = this.scopes.pop();\r\n  if (scope) {\r\n    this.currentScope = scope.parent;\r\n  } else {\r\n    this.currentScope = null;\r\n  }\r\n  return scope;\r\n};\r\n\r\n/**\r\n * Look up the namespace URI by prefix\r\n * @param {String} prefix Namespace prefix\r\n * @param {Boolean} [localOnly] Search current scope only\r\n * @returns {String} Namespace URI\r\n */\r\nNamespaceContext.prototype.getNamespaceURI = function(prefix, localOnly) {\r\n  return this.currentScope && this.currentScope.getNamespaceURI(prefix, localOnly);\r\n};\r\n\r\n/**\r\n * Look up the namespace prefix by URI\r\n * @param {String} nsURI Namespace URI\r\n * @param {Boolean} [localOnly] Search current scope only\r\n * @returns {String} Namespace prefix\r\n */\r\nNamespaceContext.prototype.getPrefix = function(nsUri, localOnly) {\r\n  return this.currentScope && this.currentScope.getPrefix(nsUri, localOnly);\r\n};\r\n\r\n/**\r\n * Register a namespace\r\n * @param {String} nsUri Namespace URI\r\n * @returns {String} The matching or generated namespace prefix\r\n */\r\nNamespaceContext.prototype.registerNamespace = function(nsUri) {\r\n  var prefix = this.getPrefix(nsUri);\r\n  if (prefix) {\r\n    // If the namespace has already mapped to a prefix\r\n    return prefix;\r\n  } else {\r\n    // Try to generate a unique namespace\r\n    while (true) {\r\n      prefix = 'ns' + (++this.prefixCount);\r\n      if (!this.getNamespaceURI(prefix)) {\r\n        // The prefix is not used\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  this.addNamespace(prefix, nsUri, true);\r\n  return prefix;\r\n};\r\n\r\n/**\r\n * Declare a namespace prefix/uri mapping\r\n * @param {String} prefix Namespace prefix\r\n * @param {String} nsUri Namespace URI\r\n * @returns {Boolean} true if the declaration is created\r\n */\r\nNamespaceContext.prototype.declareNamespace = function(prefix, nsUri) {\r\n  if (this.currentScope) {\r\n    var mapping = this.currentScope.getNamespaceMapping(prefix);\r\n    if (mapping && mapping.uri === nsUri && mapping.declared) {\r\n      return false;\r\n    }\r\n    this.currentScope.namespaces[prefix] = {\r\n      uri: nsUri,\r\n      prefix: prefix,\r\n      declared: true\r\n    };\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n"}